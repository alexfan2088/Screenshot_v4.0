using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Threading;
using static Screenshot_v3_0.Logger;

namespace Screenshot_v3_0
{
    /// <summary>
    /// 输出模式枚举
    /// </summary>
    public enum OutputMode
    {
        None,           // 不生成音视频（只生成PPT/PDF和截图）
        AudioOnly,      // 只生成音频
        VideoOnly,      // 只生成视频
        AudioAndVideo   // 音频+视频
    }

    public partial class MainWindow : Window
    {
        private readonly AudioRecorder _audioRecorder = new();
        private VideoEncoder? _videoEncoder;
        private RecordingConfig _config;
        private readonly string _workDir;
        private readonly string _configPath;
        private bool _isVideoRecording;
        private RegionHighlightWindow? _regionHighlightWindow;
        
        // 截图相关
        private DispatcherTimer? _screenshotTimer;
        private Bitmap? _lastScreenshot;
        private DateTime _lastScreenshotTime;
        private bool _keepJpgFiles; // 是否保留JPG文件（截图功能始终启用，用于生成PPT）
        private readonly string _screenshotDir;
        
        // PPT和PDF生成器
        private PPTGenerator? _pptGenerator;
        private PDFGenerator? _pdfGenerator;
        private string? _pptFilePath;
        private string? _pdfFilePath;
        private bool _pptPdfInitialized = false;
        
        // 当前录制的文件路径
        private string? _currentVideoPath;
        private string? _currentAudioPath; // 当前音频文件路径
        
        // 输出模式（默认音频+视频）
        private OutputMode _outputMode = OutputMode.AudioAndVideo;
        
        // 录制状态信息
        private DateTime _recordingStartTime;
        private int _screenshotCount = 0;
        private DispatcherTimer? _statusUpdateTimer;
        private string _currentOperation = "";
        private double _currentScreenChangeRate = 0.0; // 实时检测到的屏幕变化率
        private bool _isStoppingRecording = false;
        
        // 录制时长控制
        private int _recordingDurationMinutes = 60; // 默认60分钟
        private DispatcherTimer? _durationCheckTimer; // 检查录制时长的定时器

        public MainWindow()
        {
            InitializeComponent();
            
            // 设置窗口始终置顶
            this.Topmost = true;
            
            // 设置窗口初始位置在屏幕顶部居中
            this.WindowStartupLocation = WindowStartupLocation.Manual;
            // 设置窗口宽度为屏幕宽度的80%
            double screenWidth = SystemParameters.PrimaryScreenWidth;
            this.Width = screenWidth * 0.8;
            this.Left = (screenWidth - this.Width) / 2;
            this.Top = 10; // 距离顶部10像素
            
            // 添加窗口拖拽功能（无边框窗口需要手动实现）
            this.MouseDown += MainWindow_MouseDown;
            
            // 设置窗口关闭事件
            this.Closing += MainWindow_Closing;
            
            // 获取 .exe 所在目录
            string exeDirectory = AppDomain.CurrentDomain.BaseDirectory;
            
            // 配置文件路径：放在 .exe 所在目录
            _configPath = Path.Combine(exeDirectory, "config.json");

            // 设置工作目录：优先使用D盘，如果D盘不存在则使用C盘（用于保存录制的视频文件）
            string driveLetter = Directory.Exists("D:\\") ? "D:" : "C:";
            _workDir = Path.Combine(driveLetter, "ScreenshotV3.0");
            Directory.CreateDirectory(_workDir);
            
            // 设置截图目录：优先使用D盘，如果D盘不存在则使用C盘
            _screenshotDir = Path.Combine(driveLetter, "ScreenshotV3.0");
            Directory.CreateDirectory(_screenshotDir);

            // 加载配置
            _config = RecordingConfig.Load(_configPath);
            
            // 强制启用PPT生成（必选项）
            _config.GeneratePPT = true;
            
            // 初始化日志系统
            Logger.Enabled = _config.LogEnabled == 1;
            Logger.SetLogFileMode(_config.LogFileMode);
            // 设置日志文件目录为工作目录（与视频、音频文件同一目录）
            // SetLogDirectory 会根据模式决定是否清空日志文件
            Logger.SetLogDirectory(_workDir);
            
            // 初始化截图定时器（但不启动，只有点击开始按钮后才启动）
            _screenshotTimer = new DispatcherTimer();
            _screenshotTimer.Tick += ScreenshotTimer_Tick;
            _lastScreenshotTime = DateTime.Now;
            
            // 初始化截图功能（截图始终启用，用于生成PPT）
            // _keepJpgFiles 控制是否保留JPG文件（从配置加载）
            _keepJpgFiles = _config.KeepJpgFiles;
            if (MenuScreenshot != null)
            {
                MenuScreenshot.IsChecked = _keepJpgFiles;
            }
            
            // 注意：截图定时器不在启动时自动运行，只有点击"开始"按钮后才启动
            
            // 初始化菜单项状态
            UpdateLogMenuItems();
            UpdatePPTAndPDFMenuItems();
            UpdateOutputModeMenuItems();
            UpdateVideoMergeModeMenuItems();
            
            // 初始化界面上的设置输入框
            InitializeSettingsControls();
            
            Logger.WriteLine("程序启动");
            Logger.WriteLine($"日志状态: {(Logger.Enabled ? "启用" : "禁用")}");
            Logger.WriteLine($"日志文件模式: {(_config.LogFileMode == 0 ? "覆盖" : "叠加")}");
            
            UpdateConfigDisplay();
            
            // 初始化按钮状态：只有选择按钮可用，开始和停止按钮禁用
            InitializeButtonStates();
            
            // 延迟初始化区域高亮和截图基准画面，直到窗口加载完成
            this.Loaded += (s, e) =>
            {
                // 窗口加载完成后，初始化 _lastScreenshot 作为第一次检查的基准画面
                // 截图功能始终启用（用于生成PPT）
                UpdateLastScreenshot();
                // 动态计算信息显示区域的宽度
                UpdateStatusBarInfoWidth();
            };
            
            // 窗口大小改变时，重新计算信息显示区域的宽度
            this.SizeChanged += (s, e) =>
            {
                UpdateStatusBarInfoWidth();
            };
        }

        private void MainWindow_MouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            // 实现无边框窗口拖拽功能（只在非按钮区域才能拖拽）
            if (e.ChangedButton == System.Windows.Input.MouseButton.Left && 
                e.Source is not System.Windows.Controls.Button)
            {
                this.DragMove();
            }
        }

        private void BtnMinimize_Click(object sender, RoutedEventArgs e)
        {
            this.WindowState = WindowState.Minimized;
        }

        private void BtnClose_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private void MainWindow_Closing(object? sender, System.ComponentModel.CancelEventArgs e)
        {
            // 检查是否有正在进行的操作
            if (_isVideoRecording || _isStoppingRecording)
            {
                // 取消关闭
                e.Cancel = true;
                
                // 显示提示消息
                string message;
                if (_isVideoRecording)
                {
                    message = "正在录制视频，请先停止录制后再关闭程序。";
                }
                else if (_isStoppingRecording)
                {
                    // 根据当前操作显示具体信息
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        message = $"{_currentOperation}\n\n请等待操作完成后再关闭程序。";
                    }
                    else
                    {
                        message = "正在生成文件（MP4、PPT、PDF），请等待操作完成后再关闭程序。";
                    }
                }
                else
                {
                    message = "正在处理中，请稍候再关闭程序。";
                }
                
                MessageBox.Show(
                    message,
                    "无法关闭",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning,
                    MessageBoxResult.OK
                );
                
                WriteLine($"[窗口关闭] 阻止关闭：{message}");
                return;
            }

            // 没有正在进行的操作，允许关闭
            e.Cancel = false;

            Dispatcher.Invoke(() =>
            {
                _regionHighlightWindow?.Close();
                _regionHighlightWindow = null;
            });

            // 在后台线程执行清理
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    // 停止截图定时器
                    try
                    {
                        if (_screenshotTimer != null && _screenshotTimer.IsEnabled)
                        {
                            _screenshotTimer.Stop();
                        }
                    }
                    catch (Exception ex)
                    {
                        WriteError($"停止截图定时器时出错", ex);
                    }
                    
                    // 释放资源
                    try
                    {
                        _videoEncoder?.Dispose();
                        _audioRecorder?.Dispose();
                        _pptGenerator?.Dispose();
                        _pdfGenerator?.Dispose();
                    }
                    catch (Exception ex)
                    {
                        WriteError($"释放资源时出错", ex);
                    }
                }
                catch (Exception ex)
                {
                    WriteError($"窗口关闭处理时出错", ex);
                }
            });
        }

        private void MenuSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var settingsWindow = new SettingsWindow(_config);
                if (settingsWindow.ShowDialog() == true)
                {
                    _config = settingsWindow.Config;
                    // 强制启用PPT生成（必选项）
                    _config.GeneratePPT = true;
                    _config.Save(_configPath);
                    UpdateConfigDisplay();
                    UpdateLogMenuItems();
                    UpdatePPTAndPDFMenuItems();
                    UpdateStatusDisplay("设置已保存");
                }
            }
            catch (Exception ex)
            {
                string errorMsg = $"打开设置失败：{ex.Message}";
                if (ex.InnerException != null)
                {
                    errorMsg += $"\n详细：{ex.InnerException.Message}";
                }
                UpdateStatusDisplay(errorMsg);
                WriteError($"打开设置窗口异常", ex);
            }
        }

        private void BtnStartVideo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_isVideoRecording) return;
                _isStoppingRecording = false;

                // 每次开始录制时，清理之前的PPT/PDF生成器，确保生成新的文件
                // 因为用户可能重新选择了区域，需要生成新的文件
                if (_pptGenerator != null || _pdfGenerator != null)
                {
                    WriteLine("清理之前的PPT/PDF生成器，准备生成新文件");
                    _pptGenerator?.Dispose();
                    _pdfGenerator?.Dispose();
                    _pptGenerator = null;
                    _pdfGenerator = null;
                    _pptPdfInitialized = false;
                }

                var timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                WriteLine($"========== 开始录制 ==========");
                WriteLine($"输出模式: {_outputMode}");

                // 根据输出模式决定是否创建视频和音频
                if (_outputMode == OutputMode.None)
                {
                    // 不生成音视频模式：只启动截图功能
                    _currentVideoPath = null;
                    _videoEncoder = null;
                    _currentAudioPath = null;
                    WriteLine("不生成音视频模式：只进行截图和生成PPT/PDF");
                }
                else if (_outputMode == OutputMode.VideoOnly || _outputMode == OutputMode.AudioAndVideo)
                {
                    var videoPath = Path.Combine(_workDir, $"video{timestamp}.mp4");
                    _currentVideoPath = videoPath; // 保存当前视频文件路径

                    int videoWidth;
                    int videoHeight;
                    int offsetX = 0;
                    int offsetY = 0;

                    var (screenWidthPixels, screenHeightPixels) = GetPrimaryScreenPixelSize();

                    // 应用分辨率比例：无论是否有自定义区域，都根据分辨率比例缩放视频尺寸
                    double resolutionScale = _config.VideoResolutionScale / 100.0;
                    
                    if (HasValidCustomRegion())
                    {
                        int regionRight = _config.RegionLeft + _config.RegionWidth;
                        int regionBottom = _config.RegionTop + _config.RegionHeight;
                        
                        if (_config.RegionLeft < 0 || _config.RegionTop < 0 ||
                            regionRight > screenWidthPixels || regionBottom > screenHeightPixels)
                        {
                            string errorMsg = $"选择的录制区域超出主屏幕范围！\n" +
                                             $"区域: ({_config.RegionLeft}, {_config.RegionTop}) 到 ({regionRight}, {regionBottom})\n" +
                                             $"主屏幕: (0, 0) 到 ({screenWidthPixels}, {screenHeightPixels})\n" +
                                             $"请重新选择区域或清除区域设置使用全屏录制。";
                            
                            WriteError(errorMsg);
                            UpdateStatusDisplay("录制区域超出屏幕范围，请重新选择");
                            
                            MessageBox.Show(errorMsg, "区域超出范围", MessageBoxButton.OK, MessageBoxImage.Warning);
                            return;
                        }
                        
                        // 使用自定义区域，但应用分辨率比例缩放
                        int originalWidth = _config.RegionWidth;
                        int originalHeight = _config.RegionHeight;
                        videoWidth = (int)(originalWidth * resolutionScale);
                        videoHeight = (int)(originalHeight * resolutionScale);
                        offsetX = _config.RegionLeft;
                        offsetY = _config.RegionTop;
                        WriteLine($"使用自定义区域录制: 原始尺寸 {originalWidth}x{originalHeight}, 缩放后 {videoWidth}x{videoHeight} ({_config.VideoResolutionScale}%) @ 起点 ({offsetX}, {offsetY})");
                    }
                    else
                    {
                        // 全屏录制，应用分辨率比例
                        videoWidth = (int)(screenWidthPixels * resolutionScale);
                        videoHeight = (int)(screenHeightPixels * resolutionScale);
                        WriteLine($"全屏录制: 原始尺寸 {screenWidthPixels}x{screenHeightPixels}, 缩放后 {videoWidth}x{videoHeight} ({_config.VideoResolutionScale}%)");
                    }

                    // 创建视频编码器（不再需要 VideoRecorder，FFmpeg 直接录制）
                    _videoEncoder = new VideoEncoder(videoPath, _config);

                    // 计算原始捕获尺寸（不应用分辨率比例）
                    int captureWidth = videoWidth;
                    int captureHeight = videoHeight;
                    if (HasValidCustomRegion())
                    {
                        // 如果有自定义区域，捕获时使用原始区域尺寸
                        captureWidth = _config.RegionWidth;
                        captureHeight = _config.RegionHeight;
                    }
                    else
                    {
                        // 全屏录制，捕获时使用全屏尺寸
                        captureWidth = screenWidthPixels;
                        captureHeight = screenHeightPixels;
                    }

                    // 初始化编码器（支持自定义区域偏移和分辨率缩放）
                    // videoWidth/videoHeight 是输出尺寸（应用分辨率比例后）
                    // captureWidth/captureHeight 是捕获尺寸（原始尺寸，不缩放）
                    _videoEncoder.Initialize(videoWidth, videoHeight, _config.VideoFrameRate, 
                        _config.AudioSampleRate, 2, offsetX, offsetY, captureWidth, captureHeight);

                    WriteLine("MP4文件");
                }
                else
                {
                    _currentVideoPath = null;
                    _videoEncoder = null;
                }

                // 根据输出模式决定是否开始音频录制
                if (_outputMode == OutputMode.None)
                {
                    // 不生成音视频模式，跳过音频录制
                    _currentAudioPath = null;
                }
                else if (_outputMode == OutputMode.AudioOnly || _outputMode == OutputMode.AudioAndVideo || _outputMode == OutputMode.VideoOnly)
                {
                    // 准备音频录制路径
                    var audioOutputPath = Path.Combine(_workDir, $"audio_{timestamp}.m4a"); // 最终输出路径（不会被使用）
                    var expectedAudioPath = Path.Combine(_workDir, $"audio_{timestamp}.wav"); // AudioRecorder 实际创建的文件
                    _currentAudioPath = expectedAudioPath; // 保存音频文件路径

                    WriteLine("开始音频录制（NAudio WasapiLoopbackCapture，即使静音也会录制）");
                    WriteLine("预期WAV文件");

                    // ★★ 关键改动：改变启动顺序，确保音视频同步 ★★
                    // 1. 先初始化 AudioRecorder（获取音频格式信息，但不开始录制）
                    _audioRecorder.Initialize();

                    // 2. 设置音频格式并启动 FFmpeg（管道模式下，先让管道准备好）
                    if (_outputMode == OutputMode.VideoOnly || _outputMode == OutputMode.AudioAndVideo)
                    {
                        if (_videoEncoder != null)
                        {
                            // 设置音频格式参数
                            _videoEncoder.SetAudioFormat(
                                _audioRecorder.BitsPerSample,
                                _audioRecorder.IsFloatFormat,
                                _audioRecorder.SampleRate
                            );

                            // 启动 FFmpeg 录制（管道模式下，音频管道会在这里准备好）
                            bool useAudioPipe = _config.VideoMergeMode == 1;
                            string mergeModeName = useAudioPipe ? "边录边合（管道模式）" : "后期合并模式";
                            WriteLine($"启动 FFmpeg 录制视频（{mergeModeName}）...");
                            _videoEncoder.Start(useAudioPipe);

                            // ★★ 关键：立即发送初始静音数据，填补 FFmpeg 启动到 NAudio 启动之间的空白
                            if (useAudioPipe)
                            {
                                // 发送约2秒的初始静音，确保音频流从视频开始时就有数据
                                _videoEncoder.SendInitialSilence(2000);
                            }
                        }

                        // 3. 连接音频数据事件（FFmpeg 已启动，管道已准备好）
                        _audioRecorder.AudioSampleAvailable += OnAudioSampleAvailable;
                    }

                    // 4. 最后启动 NAudio 录制（此时管道已准备好，音频数据不会丢失）
                    _audioRecorder.Start(audioOutputPath);
                }
                else
                {
                    _currentAudioPath = null;
                }

                // 启动 FFmpeg 录制视频（仅在 AudioOnly 或 None 模式下需要单独处理）
                if (_outputMode == OutputMode.None)
                {
                    // 不生成音视频模式，跳过视频录制
                    WriteLine("不生成音视频模式：跳过视频录制");
                }
                // 注意：VideoOnly 和 AudioAndVideo 模式的 FFmpeg 启动已在上面处理

                _isVideoRecording = true;
                // 更新按钮状态
                UpdateStartButtonState();
                
                // 初始化录制状态信息
                _recordingStartTime = DateTime.Now;
                _screenshotCount = 0;
                
                // 启动状态更新定时器
                _statusUpdateTimer = new DispatcherTimer();
                _statusUpdateTimer.Interval = TimeSpan.FromMilliseconds(500); // 每500ms更新一次
                _statusUpdateTimer.Tick += StatusUpdateTimer_Tick;
                _statusUpdateTimer.Start();
                
                // 启动录制时长检查定时器（如果设置了时长限制）
                if (_recordingDurationMinutes > 0)
                {
                    _durationCheckTimer = new DispatcherTimer();
                    _durationCheckTimer.Interval = TimeSpan.FromSeconds(1); // 每秒检查一次
                    _durationCheckTimer.Tick += DurationCheckTimer_Tick;
                    _durationCheckTimer.Start();
                    WriteLine($"录制时长限制: {_recordingDurationMinutes}分钟");
                }

                // 启动截图定时器（截图功能始终启用，用于生成PPT）
                if (_screenshotTimer != null)
                {
                    _screenshotTimer.Interval = TimeSpan.FromSeconds(1);
                    _screenshotTimer.Start();
                    _lastScreenshotTime = DateTime.Now;
                    // 立即初始化 _lastScreenshot，作为第一次检查的基准画面
                    UpdateLastScreenshot();
                    WriteLine("截图定时器已启动");
                }

                // 状态显示会在定时器中更新，显示：屏幕变化率、录制间隔、截图数量
                // 立即更新一次状态
                UpdateRecordingStatus();
                
                // 立即截图一张（截图功能始终启用）
                try
                {
                    CaptureScreenshot();
                    WriteLine("开始录制时立即截图一张");
                }
                catch (Exception ex)
                {
                    WriteError($"开始录制时截图失败", ex);
                }
            }
            catch (Exception ex)
            {
                UpdateStatusDisplay($"开始录制视频失败：{ex.Message}");
            }
        }

        private void BtnStopVideo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_isVideoRecording) return;

                // ★ 立即设置录制状态为 false，防止截图定时器继续生成 JPG
                _isVideoRecording = false;

                // 先禁用按钮，防止重复点击
                BtnStopVideo.IsEnabled = false;

                _isStoppingRecording = true;
                _statusUpdateTimer?.Stop();
                _statusUpdateTimer = null;

                // 停止录制时长检查定时器
                _durationCheckTimer?.Stop();
                _durationCheckTimer = null;

                // ★ 立即停止截图定时器
                if (_screenshotTimer != null && _screenshotTimer.IsEnabled)
                {
                    _screenshotTimer.Stop();
                    WriteLine("截图定时器已停止");
                }

                // 立即更新状态显示
                _currentOperation = "正在停止录制...";
                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色

                WriteLine("准备启动停止任务...");

                // ★ 先立即关闭管道、断开事件并停止音频录制，确保音视频同时停止
                if (_outputMode == OutputMode.VideoOnly || _outputMode == OutputMode.AudioAndVideo)
                {
                    WriteLine("立即关闭 FFmpeg 音频管道...");
                    _audioRecorder.AudioSampleAvailable -= OnAudioSampleAvailable;
                    _videoEncoder?.RequestStop();

                    // ★★ 关键：立即停止 NAudio 录制，确保音频和视频时长一致
                    WriteLine("立即停止音频录制...");
                    _audioRecorder.Stop();
                    WriteLine("已关闭音频管道，FFmpeg 将自动完成编码...");
                }

                // 使用专用线程而不是线程池，避免线程池饥饿
                var stopThread = new Thread(() =>
                {
                    try
                    {
                        WriteLine($"========== 停止录制 ==========");
                        WriteLine($"输出模式: {_outputMode}");

                        List<string> generatedFiles = new List<string>();

                        // 注意：音频录制已在 UI 线程停止，这里只需要查找音频文件
                        string? audioFilePathForVideo = null;
                        if (_outputMode == OutputMode.VideoOnly || _outputMode == OutputMode.AudioAndVideo)
                        {
                            // 查找临时音频文件（用于后期合成模式）
                            var tempAudioFiles = Directory.GetFiles(_workDir, "audio_*.wav");
                            if (tempAudioFiles.Length == 0)
                            {
                                tempAudioFiles = Directory.GetFiles(_workDir, "temp_audio_*.wav");
                            }

                            if (tempAudioFiles.Length > 0)
                            {
                                var latestAudioFile = tempAudioFiles.OrderByDescending(f => File.GetCreationTime(f)).First();
                                var audioFileInfo = new FileInfo(latestAudioFile);

                                if (audioFileInfo.Length > 0)
                                {
                                    audioFilePathForVideo = latestAudioFile;
                                    _videoEncoder?.SetAudioFile(latestAudioFile);
                                }
                            }
                        }
                        else if (_outputMode == OutputMode.AudioOnly)
                        {
                            // 只生成音频模式：停止音频录制
                            WriteLine("停止音频录制");
                            _audioRecorder.Stop();
                        }
                        
                        // 第二步：生成PPT文件
                        if (_config.GeneratePPT && _pptFilePath != null)
                        {
                            Dispatcher.Invoke(() =>
                            {
                                _currentOperation = "正在生成PPT文件";
                                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                            });
                            
                            WriteLine("准备完成PPT生成");
                            if (_pptGenerator != null)
                            {
                                _pptGenerator.Finish();
                                WriteLine("PPT文件已生成");
                            }
                            
                            if (_pptFilePath != null && File.Exists(_pptFilePath))
                            {
                                generatedFiles.Add("PPT文件");
                            }
                        }
                        
                        // 第三步：生成PDF文件
                        if (_config.GeneratePDF && _pdfFilePath != null)
                        {
                            Dispatcher.Invoke(() =>
                            {
                                _currentOperation = "正在生成PDF文件";
                                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                            });
                            
                            WriteLine("准备完成PDF生成");
                            if (_pdfGenerator != null)
                            {
                                _pdfGenerator.Finish();
                                WriteLine("PDF文件已生成");
                            }
                            
                            if (_pdfFilePath != null && File.Exists(_pdfFilePath))
                            {
                                generatedFiles.Add("PDF文件");
                            }
                        }
                        
                        // 第四步：处理声音文件（AudioOnly模式）
                        if (_outputMode == OutputMode.AudioOnly)
                        {
                            Dispatcher.Invoke(() =>
                            {
                                _currentOperation = "正在生成音频文件";
                                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                            });
                            
                            // 查找生成的音频文件（可能是 wav 或 m4a）
                            if (_currentAudioPath != null && File.Exists(_currentAudioPath))
                            {
                                string ext = Path.GetExtension(_currentAudioPath).ToLower();
                                string audioType = ext == ".wav" ? "WAV" : "MP3";
                                generatedFiles.Add(ext == ".wav" ? "WAV文件" : "MP3文件");
                                WriteLine($"{audioType}文件已生成");
                            }
                            else
                            {
                                // 尝试查找最新的音频文件
                                var tempAudioFiles = Directory.GetFiles(_workDir, "audio_*.wav");
                                if (tempAudioFiles.Length > 0)
                                {
                                    generatedFiles.Add("WAV文件");
                                    WriteLine("WAV文件已生成");
                                }
                            }
                        }
                        
                        // 第五步：完成视频文件（VideoOnly/AudioAndVideo模式）
                        if (_outputMode == OutputMode.VideoOnly || _outputMode == OutputMode.AudioAndVideo)
                        {
                            Dispatcher.Invoke(() =>
                            {
                                _currentOperation = "正在生成MP4文件";
                                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                            });
                            
                            // 现在完成视频编码（会合并音频，如果需要）
                            WriteLine("准备停止视频录制（FFmpeg）并完成编码");
                            _videoEncoder?.Finish(); // 这会等待 FFmpeg 退出，然后根据模式决定是否合并音频
                            WriteLine("视频编码完成");

                            // 释放资源
                            _videoEncoder?.Dispose();

                            // 收集视频文件类型
                            if (_currentVideoPath != null && File.Exists(_currentVideoPath))
                            {
                                generatedFiles.Add("MP4文件");
                            }
                        }
                        
                        // 收集JPG文件（如果选择了保留JPG文件）
                        if (_keepJpgFiles && _screenshotCount > 0)
                        {
                            generatedFiles.Add("JPG文件");
                        }

                        // 在 UI 线程更新界面
                        Dispatcher.Invoke(() =>
                        {
                            _videoEncoder = null;

                            // 更新按钮状态（考虑区域选择情况）
                            UpdateStartButtonState();
                            
                            // 清除当前操作，恢复正常状态显示
                            _isStoppingRecording = false;
                            _currentOperation = "";
                            
                            // 显示成功消息，显示具体的文件名
                            if (generatedFiles.Count > 0)
                            {
                                string fileList = string.Join("、", generatedFiles);
                                UpdateStatusDisplayOnly($"已生成文件：{fileList}", new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 235))); // 天蓝色
                            }
                            else
                            {
                                UpdateStatusDisplay("录制已停止");
                            }
                            
                            // 清除当前视频和音频路径
                            _currentVideoPath = null;
                            _currentAudioPath = null;
                        });
                    }
                    catch (Exception ex)
                    {
                        WriteError($"停止录制失败", ex);
                        Dispatcher.Invoke(() =>
                        {
                            // 停止状态更新定时器
                            _statusUpdateTimer?.Stop();
                            _statusUpdateTimer = null;
                            _currentOperation = "";
                            _isStoppingRecording = false;
                            
                            UpdateStatusDisplay($"停止录制失败：{ex.Message}");
                            UpdateStartButtonState();
                        });
                    }
                });
                stopThread.IsBackground = true;
                stopThread.Start();
            }
            catch (Exception ex)
            {
                // 停止状态更新定时器
                _statusUpdateTimer?.Stop();
                _statusUpdateTimer = null;
                _currentOperation = "";
                _isStoppingRecording = false;
                
                UpdateStatusDisplay($"停止录制视频失败：{ex.Message}");
                UpdateStartButtonState();
            }
        }

        private void OnAudioSampleAvailable(byte[]? audioData, int bytesRecorded)
        {
            // 音频样本可用事件：将音频数据实时传递给 FFmpeg（边录边合成）
            if (audioData != null && bytesRecorded > 0 && _videoEncoder != null)
            {
                _videoEncoder.WriteAudioData(audioData, bytesRecorded);
            }
        }


        /// <summary>
        /// 动态计算并设置信息显示区域的宽度
        /// </summary>
        private void UpdateStatusBarInfoWidth()
        {
            try
            {
                if (StatusBarInfo == null) return;
                
                // 等待布局完成
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    try
                    {
                        // 获取窗口实际宽度
                        double windowWidth = this.ActualWidth;
                        
                        if (windowWidth <= 0) return;
                        
                        // 减去 Grid 的左右 Margin (8+8=16)
                        double availableWidth = windowWidth - 16;
                        
                        // 根据窗口宽度动态计算信息显示区域的宽度
                        // 使用窗口宽度的约 35-40% 作为信息显示区域
                        // 对于 1920px 屏幕的 80% (1536px)，信息区域约为 500-600px
                        // 对于较小屏幕，按比例调整，但最小不少于 200px
                        double statusBarWidth = Math.Max(200, availableWidth * 0.35);
                        
                        // 设置宽度
                        StatusBarInfo.Width = statusBarWidth;
                    }
                    catch (Exception ex)
                    {
                        WriteError($"延迟更新信息显示区域宽度失败", ex);
                    }
                }), System.Windows.Threading.DispatcherPriority.Loaded);
            }
            catch (Exception ex)
            {
                WriteError($"更新信息显示区域宽度失败", ex);
            }
        }

        private void UpdateConfigDisplay()
        {
            UpdateStatusDisplay(null);
        }

        /// <summary>
        /// 状态更新定时器事件
        /// </summary>
        private void StatusUpdateTimer_Tick(object? sender, EventArgs e)
        {
            if (_isVideoRecording && !_isStoppingRecording)
            {
                // 录制中：显示屏幕变化率、录制间隔、截图数量
                UpdateRecordingStatus();
            }
        }

        /// <summary>
        /// 录制时长检查定时器事件
        /// </summary>
        private void DurationCheckTimer_Tick(object? sender, EventArgs e)
        {
            try
            {
                if (!_isVideoRecording || _isStoppingRecording || _recordingDurationMinutes <= 0)
                {
                    return;
                }

                DateTime now = DateTime.Now;
                TimeSpan elapsed = now - _recordingStartTime;
                int elapsedSeconds = (int)elapsed.TotalSeconds;
                int durationSeconds = _recordingDurationMinutes * 60;

                // 检查是否到达录制时长
                if (elapsedSeconds >= durationSeconds)
                {
                    WriteLine($"录制时长已到达 {_recordingDurationMinutes} 分钟，自动停止录制");
                    
                    // 停止时长检查定时器
                    _durationCheckTimer?.Stop();
                    _durationCheckTimer = null;
                    
                    // 自动停止录制
                    Dispatcher.Invoke(() =>
                    {
                        if (_isVideoRecording && !_isStoppingRecording)
                        {
                            BtnStopVideo_Click(BtnStopVideo, new RoutedEventArgs());
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                WriteError($"录制时长检查失败", ex);
            }
        }

        /// <summary>
        /// 更新录制状态显示
        /// </summary>
        private void UpdateRecordingStatus()
        {
            try
            {
                if (_isStoppingRecording)
                {
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                    }
                    return;
                }

                // 计算录制已用时间和剩余时间
                DateTime now = DateTime.Now;
                TimeSpan recordingElapsed = now - _recordingStartTime;
                string timeInfo = "";
                if (_recordingDurationMinutes > 0)
                {
                    int remainingRecordingSeconds = _recordingDurationMinutes * 60 - (int)recordingElapsed.TotalSeconds;
                    if (remainingRecordingSeconds > 0)
                    {
                        int mins = remainingRecordingSeconds / 60;
                        int secs = remainingRecordingSeconds % 60;
                        timeInfo = $" | 剩余: {mins}分{secs}秒";
                    }
                    else
                    {
                        timeInfo = " | 剩余: 0秒";
                    }
                }
                else
                {
                    int elapsedMinutes = (int)recordingElapsed.TotalMinutes;
                    int elapsedSeconds = (int)recordingElapsed.TotalSeconds % 60;
                    timeInfo = $" | 已录制: {elapsedMinutes}分{elapsedSeconds}秒";
                }

                // 计算距离下次检查的剩余时间
                TimeSpan elapsed = now - _lastScreenshotTime;
                int remainingCheckSeconds = Math.Max(0, _config.ScreenshotInterval - (int)elapsed.TotalSeconds);
                
                // 始终显示实时的屏幕变化率（比较当前画面和上一次检查时的画面）
                string mainStatusText = $"屏幕变化率: {_currentScreenChangeRate:F2}% | " +
                                       $"截图数量: {_screenshotCount}{timeInfo}";
                
                // 使用Inlines来设置不同颜色的文本
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    // 使用天蓝色和粉红色交替显示信息
                    var parts = mainStatusText.Split('|');
                    for (int i = 0; i < parts.Length; i++)
                    {
                        string part = parts[i].Trim();
                        if (string.IsNullOrEmpty(part)) continue;
                        
                        // 交替使用天蓝色和粉红色
                        var color = (i % 2 == 0) 
                            ? new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 250)) // 天蓝色
                            : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)); // 粉红色
                        StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(part) 
                        { 
                            Foreground = color 
                        });
                        
                        // 添加分隔符（除了最后一个）
                        if (i < parts.Length - 1)
                        {
                            StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(" | ") 
                            { 
                                Foreground = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 250)) // 天蓝色
                            });
                        }
                    }
                    
                    if (remainingCheckSeconds > 0 && _lastScreenshot != null)
                    {
                        // 如果间隔时间未到达，在变化率后面显示剩余时间（使用粉红色）
                        StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run($" (下次检查: {remainingCheckSeconds}秒后)") 
                        { 
                            Foreground = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)) // 粉红色
                        });
                    }
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新录制状态失败", ex);
            }
        }

        /// <summary>
        /// 更新状态栏显示（合并配置信息和状态信息为一行，用不同颜色显示）
        /// </summary>
        /// <param name="statusText">状态文本，如果为null则使用当前状态</param>
        private void UpdateStatusDisplay(string? statusText = null, System.Windows.Media.Brush? statusColor = null)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    if (_isStoppingRecording && !string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                        return;
                    }

                    // 如果正在录制，显示录制状态
                    if (_isVideoRecording && statusText == null)
                    {
                        UpdateRecordingStatus();
                        return;
                    }

                    // 如果正在停止录制，显示当前操作
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                        return;
                    }

                    // 状态信息（黄色表示就绪，绿色表示正常，橙色表示警告，红色表示错误）
                    string status = statusText ?? "就绪";
                    System.Windows.Media.Brush finalStatusColor = statusColor ?? System.Windows.Media.Brushes.Green;
                    
                    // 如果没有指定颜色，根据状态文本判断颜色
                    if (statusColor == null)
                    {
                        if (status == "就绪")
                        {
                            finalStatusColor = System.Windows.Media.Brushes.Yellow; // 黄色
                        }
                        else if (status.Contains("失败") || status.Contains("错误"))
                        {
                            finalStatusColor = System.Windows.Media.Brushes.Red;
                        }
                        else if (status.Contains("警告") || status.Contains("正在"))
                        {
                            finalStatusColor = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)); // 粉红色
                        }
                    }

                    // 只显示状态信息
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(status) 
                    { 
                        Foreground = finalStatusColor
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }

        /// <summary>
        /// 更新状态显示（只显示状态文本，不显示配置信息）
        /// </summary>
        private void UpdateStatusDisplayOnly(string statusText, System.Windows.Media.Brush color)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(statusText) 
                    { 
                        Foreground = color
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }

        /// <summary>
        /// 更新状态显示（带滚动支持）
        /// </summary>
        private void UpdateStatusDisplayWithScroll(string statusText, System.Windows.Media.Brush color)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(statusText) 
                    { 
                        Foreground = color 
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }


        private bool HasValidCustomRegion()
        {
            return _config.UseCustomRegion &&
                   _config.RegionWidth > 0 &&
                   _config.RegionHeight > 0;
        }

        /// <summary>
        /// 初始化按钮状态：只有选择按钮可用，开始和停止按钮禁用
        /// </summary>
        private void InitializeButtonStates()
        {
            try
            {
                if (BtnStartVideo != null)
                {
                    BtnStartVideo.IsEnabled = false;
                }
                if (BtnStopVideo != null)
                {
                    BtnStopVideo.IsEnabled = false;
                }
                if (BtnSelectRegion != null)
                {
                    BtnSelectRegion.IsEnabled = true;
                }
            }
            catch (Exception ex)
            {
                WriteError($"初始化按钮状态失败", ex);
            }
        }

        /// <summary>
        /// 更新开始按钮的启用状态
        /// 如果没有有效区域，则禁用开始按钮
        /// </summary>
        private void UpdateStartButtonState()
        {
            try
            {
                if (BtnStartVideo != null)
                {
                    // 如果没有有效区域，则禁用开始按钮
                    if (!HasValidCustomRegion())
                    {
                        BtnStartVideo.IsEnabled = false;
                    }
                    else
                    {
                        // 否则启用开始按钮（除非正在录制）
                        BtnStartVideo.IsEnabled = !_isVideoRecording;
                    }
                }
                // 停止按钮始终跟随录制状态
                if (BtnStopVideo != null)
                {
                    BtnStopVideo.IsEnabled = _isVideoRecording;
                }
                // 选择按钮：录制时禁用，否则启用
                if (BtnSelectRegion != null)
                {
                    BtnSelectRegion.IsEnabled = !_isVideoRecording;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新开始按钮状态失败", ex);
            }
        }

        private void UpdateRegionOverlay()
        {
            try
            {
                // 如果没有有效的自定义区域，则隐藏
                if (!HasValidCustomRegion())
                {
                    _regionHighlightWindow?.HideRegion();
                    return;
                }

                // 有有效区域，显示红色矩形框
                if (_regionHighlightWindow == null)
                {
                    _regionHighlightWindow = new RegionHighlightWindow();
                    // 只在主窗口已显示时设置 Owner
                    if (IsLoaded && IsVisible)
                    {
                        _regionHighlightWindow.Owner = this;
                    }
                }
                else if (IsLoaded && IsVisible && _regionHighlightWindow.Owner == null)
                {
                    // 如果之前没有设置 Owner，现在设置
                    _regionHighlightWindow.Owner = this;
                }

                var rect = new Int32Rect(
                    _config.RegionLeft,
                    _config.RegionTop,
                    _config.RegionWidth,
                    _config.RegionHeight);

                _regionHighlightWindow.ShowRegion(rect);
            }
            catch (Exception ex)
            {
                WriteError($"更新区域高亮失败", ex);
            }
        }

        private void BtnSelectRegion_Click(object sender, RoutedEventArgs e)
        {
            RegionSelectionWindow? selector = null;
            try
            {
                if (_isVideoRecording)
                {
                    UpdateStatusDisplay("请先停止录制，再调整录制区域");
                    return;
                }

                selector = new RegionSelectionWindow
                {
                    Owner = this
                };

                bool? dialogResult = selector.ShowDialog();
                if (dialogResult == true)
                {
                    var rect = selector.SelectedRect;
                    if (rect.Width > 0 && rect.Height > 0)
                    {
                        // 验证区域是否在主屏幕范围内
                        var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                        int regionRight = rect.X + rect.Width;
                        int regionBottom = rect.Y + rect.Height;
                        
                        if (rect.X < 0 || rect.Y < 0 || regionRight > screenWidth || regionBottom > screenHeight)
                        {
                            string warningMsg = $"选择的区域部分超出主屏幕范围！\n" +
                                               $"区域: ({rect.X}, {rect.Y}) 到 ({regionRight}, {regionBottom})\n" +
                                               $"主屏幕: (0, 0) 到 ({screenWidth}, {screenHeight})\n" +
                                               $"录制时只会录制主屏幕范围内的部分。\n\n" +
                                               $"是否继续使用此区域？";
                            
                            WriteWarning(warningMsg);
                            
                            var result = MessageBox.Show(warningMsg, "区域超出范围", 
                                MessageBoxButton.YesNo, MessageBoxImage.Warning);
                            
                            if (result == MessageBoxResult.No)
                            {
                                UpdateStatusDisplay("已取消选择区域");
                                return;
                            }
                        }
                        
                        _config.UseCustomRegion = true;
                        _config.RegionLeft = rect.X;
                        _config.RegionTop = rect.Y;
                        _config.RegionWidth = rect.Width;
                        _config.RegionHeight = rect.Height;
                        _config.Save(_configPath);

                        // 用户选择新区域后，总是显示红色矩形框（不受配置影响）
                        UpdateRegionOverlay();
                        UpdateConfigDisplay();
                        
                        // 选择区域后，更新开始按钮状态
                        UpdateStartButtonState();

                        WriteLine($"选择录制区域: 左上=({rect.X},{rect.Y}), 大小={rect.Width}x{rect.Height}");
                        UpdateStatusDisplay($"已选择区域：{rect.Width}x{rect.Height} @ ({rect.X},{rect.Y})");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"选择录制区域失败", ex);
                UpdateStatusDisplay($"选择录制区域失败：{ex.Message}");
            }
            finally
            {
                // 确保窗口正确关闭和清理
                try
                {
                    if (selector != null && selector.IsVisible)
                    {
                        selector.Close();
                    }
                }
                catch
                {
                    // 忽略关闭错误
                }
            }
        }

        /// <summary>
        /// 恢复最近一次框选的区域
        /// </summary>
        private void BtnRestoreRegion_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_isVideoRecording)
                {
                    UpdateStatusDisplay("请先停止录制，再恢复录制区域");
                    return;
                }

                // 检查配置中是否有有效的区域
                if (!HasValidCustomRegion())
                {
                    UpdateStatusDisplay("没有可恢复的区域，请先选择区域");
                    WriteLine("恢复区域失败：配置中没有有效的区域信息");
                    return;
                }

                // 验证区域是否在主屏幕范围内
                var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                int regionRight = _config.RegionLeft + _config.RegionWidth;
                int regionBottom = _config.RegionTop + _config.RegionHeight;

                if (_config.RegionLeft < 0 || _config.RegionTop < 0 ||
                    regionRight > screenWidth || regionBottom > screenHeight)
                {
                    string warningMsg = $"保存的区域部分超出主屏幕范围！\n" +
                                       $"区域: ({_config.RegionLeft}, {_config.RegionTop}) 到 ({regionRight}, {regionBottom})\n" +
                                       $"主屏幕: (0, 0) 到 ({screenWidth}, {screenHeight})\n" +
                                       $"是否继续使用此区域？";

                    WriteWarning(warningMsg);

                    var result = MessageBox.Show(warningMsg, "区域超出范围",
                        MessageBoxButton.YesNo, MessageBoxImage.Warning);

                    if (result == MessageBoxResult.No)
                    {
                        UpdateStatusDisplay("已取消恢复区域");
                        return;
                    }
                }

                // 恢复区域：确保 UseCustomRegion 为 true
                _config.UseCustomRegion = true;
                _config.Save(_configPath);

                // 更新界面显示
                UpdateRegionOverlay();
                UpdateConfigDisplay();
                UpdateStartButtonState();

                WriteLine($"恢复录制区域: 左上=({_config.RegionLeft},{_config.RegionTop}), 大小={_config.RegionWidth}x{_config.RegionHeight}");
                UpdateStatusDisplay($"已恢复区域：{_config.RegionWidth}x{_config.RegionHeight} @ ({_config.RegionLeft},{_config.RegionTop})");
            }
            catch (Exception ex)
            {
                WriteError($"恢复录制区域失败", ex);
                UpdateStatusDisplay($"恢复录制区域失败：{ex.Message}");
            }
        }

        private (int width, int height) GetPrimaryScreenPixelSize()
        {
            int width = GetSystemMetrics(SM_CXSCREEN);
            int height = GetSystemMetrics(SM_CYSCREEN);

            if (width <= 0 || height <= 0)
            {
                // 回退到 WPF 的 SystemParameters（单位为 DIP，需要乘 DPI 比例，但通常足够）
                width = (int)SystemParameters.PrimaryScreenWidth;
                height = (int)SystemParameters.PrimaryScreenHeight;
            }

            return (width, height);
        }

        private const int SM_CXSCREEN = 0;
        private const int SM_CYSCREEN = 1;

        [DllImport("user32.dll")]
        private static extern int GetSystemMetrics(int nIndex);

        /// <summary>
        /// 初始化界面上的设置输入框
        /// </summary>
        private void InitializeSettingsControls()
        {
            try
            {
                if (TxtScreenChangeRate != null)
                {
                    TxtScreenChangeRate.Text = _config.ScreenChangeRate.ToString("F2");
                }
                if (TxtScreenshotInterval != null)
                {
                    TxtScreenshotInterval.Text = _config.ScreenshotInterval.ToString();
                }
                if (TxtRecordingDuration != null)
                {
                    TxtRecordingDuration.Text = _recordingDurationMinutes.ToString();
                }
            }
            catch (Exception ex)
            {
                WriteError($"初始化设置控件失败", ex);
            }
        }

        /// <summary>
        /// 屏幕变化率输入框文本更改事件
        /// </summary>
        private void TxtScreenChangeRate_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtScreenChangeRate != null && double.TryParse(TxtScreenChangeRate.Text, out double value))
                {
                    // 验证范围：1-1000
                    if (value < 1)
                    {
                        value = 1;
                        TxtScreenChangeRate.Text = "1";
                    }
                    else if (value > 1000)
                    {
                        value = 1000;
                        TxtScreenChangeRate.Text = "1000";
                    }
                    
                    // 更新配置并保存
                    if (Math.Abs(_config.ScreenChangeRate - value) > 0.01) // 避免频繁保存（浮点数比较）
                    {
                        _config.ScreenChangeRate = value;
                        _config.Save(_configPath);
                        WriteLine($"屏幕变化率已更新: {value:F2}%");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新屏幕变化率失败", ex);
            }
        }

        /// <summary>
        /// 截图间隔输入框文本更改事件
        /// </summary>
        private void TxtScreenshotInterval_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtScreenshotInterval != null && int.TryParse(TxtScreenshotInterval.Text, out int value))
                {
                    // 验证范围：1-65535
                    if (value < 1)
                    {
                        value = 1;
                        TxtScreenshotInterval.Text = "1";
                    }
                    else if (value > 65535)
                    {
                        value = 65535;
                        TxtScreenshotInterval.Text = "65535";
                    }
                    
                    // 更新配置并保存
                    if (_config.ScreenshotInterval != value)
                    {
                        _config.ScreenshotInterval = value;
                        _config.Save(_configPath);
                        WriteLine($"截图间隔已更新: {value}秒");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新截图间隔失败", ex);
            }
        }

        /// <summary>
        /// 录制时长输入框文本更改事件
        /// </summary>
        private void TxtRecordingDuration_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtRecordingDuration != null && int.TryParse(TxtRecordingDuration.Text, out int value))
                {
                    // 验证范围：0-9999（0表示无限制）
                    if (value < 0)
                    {
                        value = 0;
                        TxtRecordingDuration.Text = "0";
                    }
                    else if (value > 9999)
                    {
                        value = 9999;
                        TxtRecordingDuration.Text = "9999";
                    }
                    
                    // 更新录制时长
                    if (_recordingDurationMinutes != value)
                    {
                        _recordingDurationMinutes = value;
                        WriteLine($"录制时长已更新: {(_recordingDurationMinutes == 0 ? "无限制" : $"{_recordingDurationMinutes}分钟")}");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"录制时长输入框文本更改失败", ex);
            }
        }

        /// <summary>
        /// 更新日志菜单项状态
        /// </summary>
        private void UpdateLogMenuItems()
        {
            try
            {
                // 更新日志开关状态
                if (MenuLogEnabled != null)
                {
                    MenuLogEnabled.IsChecked = _config.LogEnabled == 1;
                }
                if (MenuLogDisabled != null)
                {
                    MenuLogDisabled.IsChecked = _config.LogEnabled == 0;
                }

                // 更新日志文件模式状态
                if (MenuLogFileOverwrite != null)
                {
                    MenuLogFileOverwrite.IsChecked = _config.LogFileMode == 0;
                }
                if (MenuLogFileAppend != null)
                {
                    MenuLogFileAppend.IsChecked = _config.LogFileMode == 1;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新日志菜单项状态失败", ex);
            }
        }

        /// <summary>
        /// 更新PPT和PDF菜单项状态
        /// </summary>
        private void UpdatePPTAndPDFMenuItems()
        {
            try
            {
                // 截图功能始终启用（用于生成PPT），所以PPT和PDF菜单项始终可用
                
                if (MenuGeneratePPT != null)
                {
                    // PPT为必选项，始终选中且禁用（用户不可取消）
                    MenuGeneratePPT.IsChecked = true;
                    MenuGeneratePPT.IsEnabled = false; // 禁用，用户无法取消选择
                    // 确保配置中PPT始终启用
                    _config.GeneratePPT = true;
                }
                if (MenuGeneratePDF != null)
                {
                    MenuGeneratePDF.IsChecked = _config.GeneratePDF;
                    MenuGeneratePDF.IsEnabled = true; // 截图功能始终启用，所以PDF菜单项始终可用
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新PPT和PDF菜单项状态失败", ex);
            }
        }

        /// <summary>
        /// 保存日志配置
        /// </summary>
        private void SaveLogConfig()
        {
            try
            {
                _config.Save(_configPath);
                Logger.SetLogFileMode(_config.LogFileMode);
                // 如果切换到覆盖模式，需要重新设置日志目录以清空文件
                if (_config.LogFileMode == 0)
                {
                    Logger.SetLogDirectory(_workDir, applyMode: true);
                }
                // 只有在日志启用时才写入日志（避免在禁用时写入）
                if (_config.LogEnabled == 1)
                {
                    Logger.WriteLine($"日志配置已更新: 状态={(_config.LogEnabled == 1 ? "启用" : "禁用")}, 模式={(_config.LogFileMode == 0 ? "覆盖" : "叠加")}");
                }
            }
            catch (Exception ex)
            {
                WriteError($"保存日志配置失败", ex);
            }
        }

        private void MenuLogEnabled_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogEnabled = 1;
                Logger.Enabled = true;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志已启用");
            }
            catch (Exception ex)
            {
                WriteError($"启用日志失败", ex);
            }
        }

        private void MenuLogDisabled_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogEnabled = 0;
                Logger.Enabled = false;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志已禁用");
            }
            catch (Exception ex)
            {
                WriteError($"禁用日志失败", ex);
            }
        }

        private void MenuLogFileOverwrite_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogFileMode = 0;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志文件模式：覆盖");
            }
            catch (Exception ex)
            {
                WriteError($"设置日志文件覆盖模式失败", ex);
            }
        }

        private void MenuLogFileAppend_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogFileMode = 1;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志文件模式：叠加");
            }
            catch (Exception ex)
            {
                WriteError($"设置日志文件叠加模式失败", ex);
            }
        }

        private void MenuScreenshot_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // "截图"菜单项只控制是否保留JPG文件，截图功能始终启用（用于生成PPT）
                _keepJpgFiles = MenuScreenshot.IsChecked;
                _config.KeepJpgFiles = _keepJpgFiles;
                _config.Save(_configPath);
                
                if (_keepJpgFiles)
                {
                    WriteLine("保留JPG文件：已启用");
                    UpdateStatusDisplay("保留JPG文件：已启用");
                }
                else
                {
                    WriteLine("保留JPG文件：已禁用（JPG文件将在添加到PPT/PDF后删除）");
                    UpdateStatusDisplay("保留JPG文件：已禁用");
                }
            }
            catch (Exception ex)
            {
                WriteError($"切换保留JPG文件设置失败", ex);
                UpdateStatusDisplay($"切换保留JPG文件设置失败：{ex.Message}");
            }
        }

        private void MenuGeneratePPT_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // PPT为必选项，不允许取消
                // 如果用户尝试取消，立即恢复为选中状态
                if (!MenuGeneratePPT.IsChecked)
                {
                    MenuGeneratePPT.IsChecked = true;
                }
                
                // 确保配置中PPT始终启用
                _config.GeneratePPT = true;
                _config.Save(_configPath);
                
                // 不显示状态消息，因为这是必选项
            }
            catch (Exception ex)
            {
                WriteError($"设置生成PPT功能失败", ex);
            }
        }

        private void MenuGeneratePDF_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.GeneratePDF = MenuGeneratePDF.IsChecked;
                _config.Save(_configPath);
                WriteLine($"生成PDF: {(_config.GeneratePDF ? "启用" : "禁用")}");
                UpdateStatusDisplay($"生成PDF: {(_config.GeneratePDF ? "已启用" : "已禁用")}");
            }
            catch (Exception ex)
            {
                WriteError($"切换生成PDF功能失败", ex);
                UpdateStatusDisplay($"切换生成PDF功能失败：{ex.Message}");
            }
        }

        /// <summary>
        /// 更新输出模式菜单项状态
        /// </summary>
        private void UpdateOutputModeMenuItems()
        {
            try
            {
                if (MenuOutputNone != null)
                {
                    MenuOutputNone.IsChecked = _outputMode == OutputMode.None;
                }
                if (MenuOutputAudioOnly != null)
                {
                    MenuOutputAudioOnly.IsChecked = _outputMode == OutputMode.AudioOnly;
                }
                if (MenuOutputVideoOnly != null)
                {
                    MenuOutputVideoOnly.IsChecked = _outputMode == OutputMode.VideoOnly;
                }
                if (MenuOutputAudioAndVideo != null)
                {
                    MenuOutputAudioAndVideo.IsChecked = _outputMode == OutputMode.AudioAndVideo;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新输出模式菜单项状态失败", ex);
            }
        }

        private void MenuOutputNone_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _outputMode = OutputMode.None;
                UpdateOutputModeMenuItems();
                WriteLine("输出模式：不生成音视频（只生成PPT/PDF和截图）");
                UpdateStatusDisplay("输出模式：不生成音视频");
            }
            catch (Exception ex)
            {
                WriteError($"设置输出模式失败", ex);
                UpdateStatusDisplay($"设置输出模式失败：{ex.Message}");
            }
        }

        private void MenuOutputAudioOnly_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _outputMode = OutputMode.AudioOnly;
                UpdateOutputModeMenuItems();
                WriteLine("输出模式：只生成音频");
                UpdateStatusDisplay("输出模式：只生成音频");
            }
            catch (Exception ex)
            {
                WriteError($"设置输出模式失败", ex);
                UpdateStatusDisplay($"设置输出模式失败：{ex.Message}");
            }
        }

        private void MenuOutputVideoOnly_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _outputMode = OutputMode.VideoOnly;
                UpdateOutputModeMenuItems();
                WriteLine("输出模式：只生成视频文件");
                UpdateStatusDisplay("输出模式：只生成视频文件");
            }
            catch (Exception ex)
            {
                WriteError($"设置输出模式失败", ex);
                UpdateStatusDisplay($"设置输出模式失败：{ex.Message}");
            }
        }

        private void MenuOutputAudioAndVideo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _outputMode = OutputMode.AudioAndVideo;
                UpdateOutputModeMenuItems();
                WriteLine("输出模式：音频+视频");
                UpdateStatusDisplay("输出模式：音频+视频");
            }
            catch (Exception ex)
            {
                WriteError($"设置输出模式失败", ex);
                UpdateStatusDisplay($"设置输出模式失败：{ex.Message}");
            }
        }

        private void MenuMergeRealtime_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.VideoMergeMode = 1; // 边录边合
                UpdateVideoMergeModeMenuItems();
                _config.Save(_configPath);
                WriteLine("视频合成方式：边录边合（管道模式，停止后秒级完成）");
                UpdateStatusDisplay("合成方式：边录边合");
            }
            catch (Exception ex)
            {
                WriteError($"设置视频合成方式失败", ex);
                UpdateStatusDisplay($"设置视频合成方式失败：{ex.Message}");
            }
        }

        private void MenuMergePostProcess_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.VideoMergeMode = 0; // 后期合成
                UpdateVideoMergeModeMenuItems();
                _config.Save(_configPath);
                WriteLine("视频合成方式：后期合成（长视频需等待）");
                UpdateStatusDisplay("合成方式：后期合成");
            }
            catch (Exception ex)
            {
                WriteError($"设置视频合成方式失败", ex);
                UpdateStatusDisplay($"设置视频合成方式失败：{ex.Message}");
            }
        }

        private void UpdateVideoMergeModeMenuItems()
        {
            try
            {
                if (MenuMergeRealtime != null)
                {
                    MenuMergeRealtime.IsChecked = _config.VideoMergeMode == 1;
                }
                if (MenuMergePostProcess != null)
                {
                    MenuMergePostProcess.IsChecked = _config.VideoMergeMode == 0;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新视频合成方式菜单状态失败", ex);
            }
        }

        private void ScreenshotTimer_Tick(object? sender, EventArgs e)
        {
            try
            {
                // 截图功能始终启用，只需要检查是否正在录制
                if (!_isVideoRecording) return;

                DateTime now = DateTime.Now;
                TimeSpan elapsed = now - _lastScreenshotTime;
                
                // 持续计算屏幕变化率（用于实时显示）
                // 这比较的是"上一次检查时的画面"（间隔时间前的画面）和"当前画面"的变化率
                // 注意：这里不更新 _lastScreenshot，只计算变化率用于显示
                double changeRate = CalculateScreenChangeRateForDisplay();
                _currentScreenChangeRate = changeRate;
                
                // 检查是否到了截图间隔时间
                if (elapsed.TotalSeconds >= _config.ScreenshotInterval)
                {
                    // 间隔时间到达，检查是否需要截图
                    if (changeRate >= _config.ScreenChangeRate || _lastScreenshot == null)
                    {
                        // 屏幕变化率超过阈值，执行截图
                        CaptureScreenshot();
                    }
                    
                    // 间隔时间到达，更新 _lastScreenshot 为当前画面（保存为"上一次检查时的画面"）
                    UpdateLastScreenshot();
                    _lastScreenshotTime = now;
                }
            }
            catch (Exception ex)
            {
                WriteError($"截图定时器处理失败", ex);
            }
        }

        /// <summary>
        /// 计算屏幕变化率（仅用于显示，不更新 _lastScreenshot）
        /// 比较"上一次检查时的画面"（间隔时间前的画面）和"当前画面"的变化率
        /// </summary>
        private double CalculateScreenChangeRateForDisplay()
        {
            Bitmap? currentScreenshot = null;
            try
            {
                // 获取当前屏幕截图
                currentScreenshot = CaptureScreenBitmap();
                
                if (_lastScreenshot == null)
                {
                    // 第一次，还没有基准画面，返回最大值
                    currentScreenshot?.Dispose();
                    return 1000;
                }

                // 检查两张图片的尺寸是否匹配
                if (currentScreenshot.Width != _lastScreenshot.Width || 
                    currentScreenshot.Height != _lastScreenshot.Height)
                {
                    // 尺寸不匹配（可能是区域选择改变了），返回最大值表示需要更新
                    currentScreenshot?.Dispose();
                    return 1000;
                }

                // 比较两张图片的差异（参考Python代码的pixel_diff函数）
                // Python逻辑：np.any(diff > 20, axis=2) - 如果任何一个颜色通道的差值超过20，认为像素变化
                int changedPixels = 0;

                // 为了提高性能，使用采样方式（每5个像素采样一次）
                // 但计算方式与Python保持一致：检查任何一个通道是否超过20
                int sampleRate = 5;
                int sampledPixels = 0;
                
                // 使用较小的尺寸确保不越界
                int width = Math.Min(currentScreenshot.Width, _lastScreenshot.Width);
                int height = Math.Min(currentScreenshot.Height, _lastScreenshot.Height);
                
                for (int y = 0; y < height; y += sampleRate)
                {
                    for (int x = 0; x < width; x += sampleRate)
                    {
                        // 确保坐标在有效范围内
                        if (x >= currentScreenshot.Width || y >= currentScreenshot.Height ||
                            x >= _lastScreenshot.Width || y >= _lastScreenshot.Height)
                        {
                            continue;
                        }
                        
                        Color currentColor = currentScreenshot.GetPixel(x, y);
                        Color lastColor = _lastScreenshot.GetPixel(x, y);
                        
                        // 计算每个颜色通道的差值（参考Python: np.abs(arr1 - arr2)）
                        int diffR = Math.Abs(currentColor.R - lastColor.R);
                        int diffG = Math.Abs(currentColor.G - lastColor.G);
                        int diffB = Math.Abs(currentColor.B - lastColor.B);
                        
                        // Python逻辑：np.any(diff > 20, axis=2) - 如果任何一个通道差值超过20，认为像素变化
                        if (diffR > 20 || diffG > 20 || diffB > 20)
                        {
                            changedPixels++;
                        }
                        sampledPixels++;
                    }
                }

                // 计算变化率（百分比）：基于采样像素的变化率
                // Python逻辑：rate = (changed_count / total) * 100
                double sampledChangeRate = (changedPixels / (double)sampledPixels) * 100.0;
                
                // 释放当前截图（不更新 _lastScreenshot）
                currentScreenshot?.Dispose();
                
                return sampledChangeRate;
            }
            catch (Exception ex)
            {
                WriteError($"计算屏幕变化率失败", ex);
                currentScreenshot?.Dispose(); // 确保在异常时释放资源
                return 0;
            }
        }

        /// <summary>
        /// 更新 _lastScreenshot 为当前画面（仅在间隔时间到达时调用）
        /// </summary>
        private void UpdateLastScreenshot()
        {
            try
            {
                Bitmap? currentScreenshot = CaptureScreenBitmap();
                _lastScreenshot?.Dispose();
                _lastScreenshot = currentScreenshot;
            }
            catch (Exception ex)
            {
                WriteError($"更新上次截图失败", ex);
            }
        }

        private Bitmap CaptureScreenBitmap()
        {
            try
            {
                // 如果设置了框选区域，只捕获框选区域；否则捕获整个屏幕
                if (HasValidCustomRegion())
                {
                    // 向内收缩几个像素，避开红色框的边框（红色框边框宽度为2像素，收缩3像素更安全）
                    const int borderOffset = 3;
                    int offsetX = _config.RegionLeft + borderOffset;
                    int offsetY = _config.RegionTop + borderOffset;
                    int width = _config.RegionWidth - borderOffset * 2;  // 左右各收缩
                    int height = _config.RegionHeight - borderOffset * 2; // 上下各收缩
                    
                    // 确保宽度和高度为正数
                    if (width <= 0) width = 1;
                    if (height <= 0) height = 1;
                    
                    Bitmap bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(
                            offsetX, 
                            offsetY, 
                            0, 
                            0, 
                            new System.Drawing.Size(width, height)
                        );
                    }
                    return bitmap;
                }
                else
                {
                    // 没有框选区域，捕获整个屏幕
                    var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                    Bitmap bitmap = new Bitmap(screenWidth, screenHeight);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(0, 0, 0, 0, new System.Drawing.Size(screenWidth, screenHeight));
                    }
                    return bitmap;
                }
            }
            catch (Exception ex)
            {
                WriteError($"捕获屏幕位图失败", ex);
                throw;
            }
        }

        private void CaptureScreenshot()
        {
            try
            {
                // 只有在正在录制时才截图，避免停止录制后继续生成PPT/PDF
                if (!_isVideoRecording)
                {
                    WriteLine("[截图] 跳过截图：录制已停止");
                    return;
                }

                int width, height;
                Bitmap bitmap;
                
                // 如果设置了框选区域，只捕获框选区域；否则捕获整个屏幕
                if (HasValidCustomRegion())
                {
                    // 向内收缩几个像素，避开红色框的边框（红色框边框宽度为2像素，收缩3像素更安全）
                    const int borderOffset = 3;
                    int offsetX = _config.RegionLeft + borderOffset;
                    int offsetY = _config.RegionTop + borderOffset;
                    width = _config.RegionWidth - borderOffset * 2;  // 左右各收缩
                    height = _config.RegionHeight - borderOffset * 2; // 上下各收缩
                    
                    // 确保宽度和高度为正数
                    if (width <= 0) width = 1;
                    if (height <= 0) height = 1;
                    
                    bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(
                            offsetX, 
                            offsetY, 
                            0, 
                            0, 
                            new System.Drawing.Size(width, height)
                        );
                    }
                }
                else
                {
                    var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                    width = screenWidth;
                    height = screenHeight;
                    bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(0, 0, 0, 0, new System.Drawing.Size(width, height));
                    }
                }
                
                using (bitmap)
                {
                    // 生成文件名：Picyymmddhhmmss.jpg
                    string fileName = $"Pic{DateTime.Now:yyMMddHHmmss}.jpg";
                    string filePath = Path.Combine(_screenshotDir, fileName);
                    
                    // 保存为JPG格式
                    ImageCodecInfo? jpegCodec = ImageCodecInfo.GetImageEncoders()
                        .FirstOrDefault(codec => codec.FormatID == ImageFormat.Jpeg.Guid);
                    
                    if (jpegCodec != null)
                    {
                        EncoderParameters encoderParams = new EncoderParameters(1);
                        encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, 90L); // 90%质量
                        bitmap.Save(filePath, jpegCodec, encoderParams);
                        encoderParams.Dispose();
                    }
                    else
                    {
                        // 如果没有找到JPEG编码器，使用默认方式保存
                        bitmap.Save(filePath, ImageFormat.Jpeg);
                    }
                    
                    WriteLine("截图已保存（JPG文件）");
                    
                    // 增加截图计数
                    _screenshotCount++;
                    
                    // 如果启用了PPT或PDF生成，立即添加到PPT/PDF
                    bool addedToPPT = false;
                    bool addedToPDF = false;
                    
                    if (_config.GeneratePPT || _config.GeneratePDF)
                    {
                        InitializePPTAndPDF(width, height);
                        
                        if (_config.GeneratePPT && _pptGenerator != null)
                        {
                            try
                            {
                                _pptGenerator.AddImage(filePath);
                                addedToPPT = true;
                            }
                            catch (Exception ex)
                            {
                                WriteError($"添加图片到PPT失败", ex);
                            }
                        }
                        
                        if (_config.GeneratePDF && _pdfGenerator != null)
                        {
                            try
                            {
                                _pdfGenerator.AddImage(filePath);
                                addedToPDF = true;
                            }
                            catch (Exception ex)
                            {
                                WriteError($"添加图片到PDF失败", ex);
                            }
                        }
                    }
                    
                    // 如果图片已成功添加到PPT或PDF，且用户选择不保留JPG文件，则删除JPG文件
                    // 注意：PPT是必选项，所以图片应该总是会被添加到PPT
                    if ((_config.GeneratePPT && addedToPPT) || (_config.GeneratePDF && addedToPDF))
                    {
                        if (!_keepJpgFiles)
                        {
                            try
                            {
                                if (File.Exists(filePath))
                                {
                                    File.Delete(filePath);
                                    WriteLine("已删除JPG文件（已添加到PPT/PDF）");
                                }
                            }
                            catch (Exception ex)
                            {
                                WriteError($"删除JPG文件失败: {filePath}", ex);
                            }
                        }
                        else
                        {
                            WriteLine("保留JPG文件");
                        }
                    }
                    else
                    {
                        // 如果没有添加到PPT/PDF（这种情况理论上不应该发生，因为PPT是必选项）
                        // 为了安全，始终保留文件
                        WriteLine("保留JPG文件（未添加到PPT/PDF）");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"截图保存失败", ex);
            }
        }

        private void InitializePPTAndPDF(int width, int height)
        {
            if (_pptPdfInitialized) return;
            
            try
            {
                if (_config.GeneratePPT)
                {
                    string timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                    _pptFilePath = Path.Combine(_screenshotDir, $"PPT{timestamp}.pptx");
                    _pptGenerator = new PPTGenerator(_pptFilePath, width, height);
                    _pptGenerator.Initialize();
                    WriteLine("PPT生成器已初始化");
                }
                
                if (_config.GeneratePDF)
                {
                    string timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                    _pdfFilePath = Path.Combine(_screenshotDir, $"PDF{timestamp}.pdf");
                    _pdfGenerator = new PDFGenerator(_pdfFilePath, width, height);
                    _pdfGenerator.Initialize();
                    WriteLine("PDF生成器已初始化");
                }
                
                _pptPdfInitialized = true;
            }
            catch (Exception ex)
            {
                WriteError($"初始化PPT/PDF生成器失败", ex);
            }
        }

        private void FinalizePPTAndPDF()
        {
            try
            {
                if (_config.GeneratePPT && _pptGenerator != null)
                {
                    _pptGenerator.Finish();
                    WriteLine("PPT文件已生成");
                }
                
                if (_config.GeneratePDF && _pdfGenerator != null)
                {
                    _pdfGenerator.Finish();
                    WriteLine("PDF文件已生成");
                }
            }
            catch (Exception ex)
            {
                WriteError($"完成PPT/PDF生成失败", ex);
            }
            finally
            {
                _pptGenerator?.Dispose();
                _pdfGenerator?.Dispose();
                _pptGenerator = null;
                _pdfGenerator = null;
                _pptPdfInitialized = false;
            }
        }
    }
}

