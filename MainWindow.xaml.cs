using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Threading;
using static Screenshot_v3_0.Logger;

namespace Screenshot_v3_0
{
    public partial class MainWindow : Window
    {
        private readonly AudioRecorder _audioRecorder = new();
        private VideoEncoder? _videoEncoder;
        private RecordingConfig _config;
        private readonly string _workDir;
        private readonly string _configPath;
        private bool _isVideoRecording;
        private RegionHighlightWindow? _regionHighlightWindow;
        
        // 截图相关
        private DispatcherTimer? _screenshotTimer;
        private Bitmap? _lastScreenshot;
        private DateTime _lastScreenshotTime;
        private bool _isScreenshotEnabled;
        private readonly string _screenshotDir;
        
        // PPT和PDF生成器
        private PPTGenerator? _pptGenerator;
        private PDFGenerator? _pdfGenerator;
        private string? _pptFilePath;
        private string? _pdfFilePath;
        private bool _pptPdfInitialized = false;
        
        // 当前录制的文件路径
        private string? _currentVideoPath;
        
        // 录制状态信息
        private DateTime _recordingStartTime;
        private int _screenshotCount = 0;
        private DispatcherTimer? _statusUpdateTimer;
        private string _currentOperation = "";
        private double _currentScreenChangeRate = 0.0; // 实时检测到的屏幕变化率
        private bool _isStoppingRecording = false;
        
        // 录制时长控制
        private int _recordingDurationMinutes = 60; // 默认60分钟
        private DispatcherTimer? _durationCheckTimer; // 检查录制时长的定时器

        public MainWindow()
        {
            InitializeComponent();
            
            // 设置窗口始终置顶
            this.Topmost = true;
            
            // 设置窗口初始位置在屏幕顶部居中
            this.WindowStartupLocation = WindowStartupLocation.Manual;
            // 设置窗口宽度为屏幕宽度的80%
            double screenWidth = SystemParameters.PrimaryScreenWidth;
            this.Width = screenWidth * 0.8;
            this.Left = (screenWidth - this.Width) / 2;
            this.Top = 10; // 距离顶部10像素
            
            // 添加窗口拖拽功能（无边框窗口需要手动实现）
            this.MouseDown += MainWindow_MouseDown;
            
            // 设置窗口关闭事件
            this.Closing += MainWindow_Closing;
            
            // 获取 .exe 所在目录
            string exeDirectory = AppDomain.CurrentDomain.BaseDirectory;
            
            // 配置文件路径：放在 .exe 所在目录
            _configPath = Path.Combine(exeDirectory, "config.json");

            // 设置工作目录：优先使用D盘，如果D盘不存在则使用C盘（用于保存录制的视频文件）
            string driveLetter = Directory.Exists("D:\\") ? "D:" : "C:";
            _workDir = Path.Combine(driveLetter, "ScreenshotV3.0");
            Directory.CreateDirectory(_workDir);
            
            // 设置截图目录：优先使用D盘，如果D盘不存在则使用C盘
            _screenshotDir = Path.Combine(driveLetter, "ScreenshotV3.0");
            Directory.CreateDirectory(_screenshotDir);

            // 加载配置
            _config = RecordingConfig.Load(_configPath);
            
            // 初始化日志系统
            Logger.Enabled = _config.LogEnabled == 1;
            Logger.SetLogFileMode(_config.LogFileMode);
            // 设置日志文件目录为工作目录（与视频、音频文件同一目录）
            // SetLogDirectory 会根据模式决定是否清空日志文件
            Logger.SetLogDirectory(_workDir);
            
            // 初始化截图定时器（但不启动，只有点击开始按钮后才启动）
            _screenshotTimer = new DispatcherTimer();
            _screenshotTimer.Tick += ScreenshotTimer_Tick;
            _lastScreenshotTime = DateTime.Now;
            
            // 初始化截图功能（默认开启，但定时器不启动）
            _isScreenshotEnabled = true;
            if (MenuScreenshot != null)
            {
                MenuScreenshot.IsChecked = true;
            }
            
            // 注意：截图定时器不在启动时自动运行，只有点击"开始"按钮后才启动
            
            // 初始化菜单项状态
            UpdateLogMenuItems();
            UpdatePPTAndPDFMenuItems();
            
            // 初始化界面上的设置输入框
            InitializeSettingsControls();
            
            Logger.WriteLine("程序启动");
            Logger.WriteLine($"日志状态: {(Logger.Enabled ? "启用" : "禁用")}");
            Logger.WriteLine($"日志文件模式: {(_config.LogFileMode == 0 ? "覆盖" : "叠加")}");
            
            UpdateConfigDisplay();
            
            // 初始化按钮状态：只有选择按钮可用，开始和停止按钮禁用
            InitializeButtonStates();
            
            // 延迟初始化区域高亮和截图基准画面，直到窗口加载完成
            this.Loaded += (s, e) =>
            {
                // 窗口加载完成后，初始化 _lastScreenshot 作为第一次检查的基准画面
                if (_isScreenshotEnabled)
                {
                    UpdateLastScreenshot();
                }
                // 动态计算信息显示区域的宽度
                UpdateStatusBarInfoWidth();
            };
            
            // 窗口大小改变时，重新计算信息显示区域的宽度
            this.SizeChanged += (s, e) =>
            {
                UpdateStatusBarInfoWidth();
            };
        }

        private void MainWindow_MouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            // 实现无边框窗口拖拽功能（只在非按钮区域才能拖拽）
            if (e.ChangedButton == System.Windows.Input.MouseButton.Left && 
                e.Source is not System.Windows.Controls.Button)
            {
                this.DragMove();
            }
        }

        private void BtnMinimize_Click(object sender, RoutedEventArgs e)
        {
            this.WindowState = WindowState.Minimized;
        }

        private void BtnClose_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private void MainWindow_Closing(object? sender, System.ComponentModel.CancelEventArgs e)
        {
            // 检查是否有正在进行的操作
            if (_isVideoRecording || _isStoppingRecording)
            {
                // 取消关闭
                e.Cancel = true;
                
                // 显示提示消息
                string message;
                if (_isVideoRecording)
                {
                    message = "正在录制视频，请先停止录制后再关闭程序。";
                }
                else if (_isStoppingRecording)
                {
                    // 根据当前操作显示具体信息
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        message = $"{_currentOperation}\n\n请等待操作完成后再关闭程序。";
                    }
                    else
                    {
                        message = "正在生成文件（MP4、PPT、PDF），请等待操作完成后再关闭程序。";
                    }
                }
                else
                {
                    message = "正在处理中，请稍候再关闭程序。";
                }
                
                MessageBox.Show(
                    message,
                    "无法关闭",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning,
                    MessageBoxResult.OK
                );
                
                WriteLine($"[窗口关闭] 阻止关闭：{message}");
                return;
            }

            // 没有正在进行的操作，允许关闭
            e.Cancel = false;

            Dispatcher.Invoke(() =>
            {
                _regionHighlightWindow?.Close();
                _regionHighlightWindow = null;
            });

            // 在后台线程执行清理
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    // 停止截图定时器
                    try
                    {
                        if (_screenshotTimer != null && _screenshotTimer.IsEnabled)
                        {
                            _screenshotTimer.Stop();
                        }
                    }
                    catch (Exception ex)
                    {
                        WriteError($"停止截图定时器时出错", ex);
                    }
                    
                    // 释放资源
                    try
                    {
                        _videoEncoder?.Dispose();
                        _audioRecorder?.Dispose();
                        _pptGenerator?.Dispose();
                        _pdfGenerator?.Dispose();
                    }
                    catch (Exception ex)
                    {
                        WriteError($"释放资源时出错", ex);
                    }
                }
                catch (Exception ex)
                {
                    WriteError($"窗口关闭处理时出错", ex);
                }
            });
        }

        private void MenuSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var settingsWindow = new SettingsWindow(_config);
                if (settingsWindow.ShowDialog() == true)
                {
                    _config = settingsWindow.Config;
                    _config.Save(_configPath);
                    UpdateConfigDisplay();
                    UpdateLogMenuItems();
                    UpdatePPTAndPDFMenuItems();
                    UpdateStatusDisplay("设置已保存");
                }
            }
            catch (Exception ex)
            {
                string errorMsg = $"打开设置失败：{ex.Message}";
                if (ex.InnerException != null)
                {
                    errorMsg += $"\n详细：{ex.InnerException.Message}";
                }
                UpdateStatusDisplay(errorMsg);
                WriteError($"打开设置窗口异常", ex);
            }
        }

        private void BtnStartVideo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_isVideoRecording) return;
                _isStoppingRecording = false;

                // 每次开始录制时，清理之前的PPT/PDF生成器，确保生成新的文件
                // 因为用户可能重新选择了区域，需要生成新的文件
                if (_pptGenerator != null || _pdfGenerator != null)
                {
                    WriteLine("清理之前的PPT/PDF生成器，准备生成新文件");
                    _pptGenerator?.Dispose();
                    _pdfGenerator?.Dispose();
                    _pptGenerator = null;
                    _pdfGenerator = null;
                    _pptPdfInitialized = false;
                }

                var videoPath = Path.Combine(_workDir, $"video{DateTime.Now:yyMMddHHmmss}.mp4");
                _currentVideoPath = videoPath; // 保存当前视频文件路径

                int videoWidth;
                int videoHeight;
                int offsetX = 0;
                int offsetY = 0;

                var (screenWidthPixels, screenHeightPixels) = GetPrimaryScreenPixelSize();

                // 应用分辨率比例：无论是否有自定义区域，都根据分辨率比例缩放视频尺寸
                double resolutionScale = _config.VideoResolutionScale / 100.0;
                
                if (HasValidCustomRegion())
                {
                    int regionRight = _config.RegionLeft + _config.RegionWidth;
                    int regionBottom = _config.RegionTop + _config.RegionHeight;
                    
                    if (_config.RegionLeft < 0 || _config.RegionTop < 0 ||
                        regionRight > screenWidthPixels || regionBottom > screenHeightPixels)
                    {
                        string errorMsg = $"选择的录制区域超出主屏幕范围！\n" +
                                         $"区域: ({_config.RegionLeft}, {_config.RegionTop}) 到 ({regionRight}, {regionBottom})\n" +
                                         $"主屏幕: (0, 0) 到 ({screenWidthPixels}, {screenHeightPixels})\n" +
                                         $"请重新选择区域或清除区域设置使用全屏录制。";
                        
                        WriteError(errorMsg);
                        UpdateStatusDisplay("录制区域超出屏幕范围，请重新选择");
                        
                        MessageBox.Show(errorMsg, "区域超出范围", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    
                    // 使用自定义区域，但应用分辨率比例缩放
                    int originalWidth = _config.RegionWidth;
                    int originalHeight = _config.RegionHeight;
                    videoWidth = (int)(originalWidth * resolutionScale);
                    videoHeight = (int)(originalHeight * resolutionScale);
                    offsetX = _config.RegionLeft;
                    offsetY = _config.RegionTop;
                    WriteLine($"使用自定义区域录制: 原始尺寸 {originalWidth}x{originalHeight}, 缩放后 {videoWidth}x{videoHeight} ({_config.VideoResolutionScale}%) @ 起点 ({offsetX}, {offsetY})");
                }
                else
                {
                    // 全屏录制，应用分辨率比例
                    videoWidth = (int)(screenWidthPixels * resolutionScale);
                    videoHeight = (int)(screenHeightPixels * resolutionScale);
                    WriteLine($"全屏录制: 原始尺寸 {screenWidthPixels}x{screenHeightPixels}, 缩放后 {videoWidth}x{videoHeight} ({_config.VideoResolutionScale}%)");
                }

                // 创建视频编码器（不再需要 VideoRecorder，FFmpeg 直接录制）
                _videoEncoder = new VideoEncoder(videoPath, _config);

                // 计算原始捕获尺寸（不应用分辨率比例）
                int captureWidth = videoWidth;
                int captureHeight = videoHeight;
                if (HasValidCustomRegion())
                {
                    // 如果有自定义区域，捕获时使用原始区域尺寸
                    captureWidth = _config.RegionWidth;
                    captureHeight = _config.RegionHeight;
                }
                else
                {
                    // 全屏录制，捕获时使用全屏尺寸
                    captureWidth = screenWidthPixels;
                    captureHeight = screenHeightPixels;
                }

                // 初始化编码器（支持自定义区域偏移和分辨率缩放）
                // videoWidth/videoHeight 是输出尺寸（应用分辨率比例后）
                // captureWidth/captureHeight 是捕获尺寸（原始尺寸，不缩放）
                _videoEncoder.Initialize(videoWidth, videoHeight, _config.VideoFrameRate, 
                    _config.AudioSampleRate, 2, offsetX, offsetY, captureWidth, captureHeight);

                // 开始音频录制（使用 NAudio WasapiLoopbackCapture，无需虚拟声卡）
                // 注意：无论是否有声音输出，都要录制音频（包括静音）
                // AudioRecorder.Start() 会创建与目标同名的临时 wav 文件
                var timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                var audioOutputPath = Path.Combine(_workDir, $"audio_{timestamp}.m4a"); // 最终输出路径（不会被使用）
                var expectedAudioPath = Path.Combine(_workDir, $"audio_{timestamp}.wav"); // AudioRecorder 实际创建的文件
                WriteLine($"========== 开始录制 ==========");
                WriteLine($"视频文件: {videoPath}");
                WriteLine($"开始音频录制（NAudio WasapiLoopbackCapture，即使静音也会录制），输出路径: {audioOutputPath}");
                WriteLine($"预期音频文件: {expectedAudioPath}");
                
                // 连接音频数据事件，实现边录边合成
                _audioRecorder.AudioSampleAvailable += OnAudioSampleAvailable;
                
                _audioRecorder.Start(audioOutputPath);
                
                // 等待音频录制启动
                System.Threading.Thread.Sleep(300);
                
                // 启动 FFmpeg 录制视频
                // VideoEncoder.Start() 会尝试直接录制有声视频，如果失败则使用音频管道实时合成
                WriteLine($"启动 FFmpeg 录制视频...");
                _videoEncoder.Start();

                _isVideoRecording = true;
                // 更新按钮状态
                UpdateStartButtonState();
                
                // 初始化录制状态信息
                _recordingStartTime = DateTime.Now;
                _screenshotCount = 0;
                
                // 启动状态更新定时器
                _statusUpdateTimer = new DispatcherTimer();
                _statusUpdateTimer.Interval = TimeSpan.FromMilliseconds(500); // 每500ms更新一次
                _statusUpdateTimer.Tick += StatusUpdateTimer_Tick;
                _statusUpdateTimer.Start();
                
                // 启动录制时长检查定时器（如果设置了时长限制）
                if (_recordingDurationMinutes > 0)
                {
                    _durationCheckTimer = new DispatcherTimer();
                    _durationCheckTimer.Interval = TimeSpan.FromSeconds(1); // 每秒检查一次
                    _durationCheckTimer.Tick += DurationCheckTimer_Tick;
                    _durationCheckTimer.Start();
                    WriteLine($"录制时长限制: {_recordingDurationMinutes}分钟");
                }

                // 启动截图定时器（只有在开始录制时才启动）
                if (_isScreenshotEnabled && _screenshotTimer != null)
                {
                    _screenshotTimer.Interval = TimeSpan.FromSeconds(1);
                    _screenshotTimer.Start();
                    _lastScreenshotTime = DateTime.Now;
                    // 立即初始化 _lastScreenshot，作为第一次检查的基准画面
                    UpdateLastScreenshot();
                    WriteLine("截图定时器已启动");
                }

                // 状态显示会在定时器中更新，显示：屏幕变化率、录制间隔、截图数量
                // 立即更新一次状态
                UpdateRecordingStatus();
                
                // 如果截图功能开启，立即截图一张
                if (_isScreenshotEnabled)
                {
                    try
                    {
                        CaptureScreenshot();
                        WriteLine("开始录制时立即截图一张");
                    }
                    catch (Exception ex)
                    {
                        WriteError($"开始录制时截图失败", ex);
                    }
                }
            }
            catch (Exception ex)
            {
                UpdateStatusDisplay($"开始录制视频失败：{ex.Message}");
            }
        }

        private void BtnStopVideo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_isVideoRecording) return;

                // 先禁用按钮，防止重复点击
                BtnStopVideo.IsEnabled = false;
                
                _isStoppingRecording = true;
                _statusUpdateTimer?.Stop();
                _statusUpdateTimer = null;
                
                // 停止录制时长检查定时器
                _durationCheckTimer?.Stop();
                _durationCheckTimer = null;
                
                // 立即更新状态显示
                _currentOperation = "正在停止录制...";
                UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色

                // 在后台线程执行停止操作，避免阻塞 UI
                ThreadPool.QueueUserWorkItem(_ =>
                {
                    try
                    {
                        // 同时停止视频和音频录制，确保时长一致
                        WriteLine($"========== 停止录制 ==========");
                        WriteLine($"同时停止视频和音频录制...");
                        
                        // 先发送停止信号给 FFmpeg（不等待完成）
                        _videoEncoder?.RequestStop();
                        
                        // 断开音频事件连接（避免继续写入数据）
                        _audioRecorder.AudioSampleAvailable -= OnAudioSampleAvailable;
                        
                        // 立即停止音频录制（与视频同时停止）
                        WriteLine($"停止音频录制");
                        _audioRecorder.Stop();
                        
                        // 更新状态：正在生成MP4文件
                        string videoFileName = _currentVideoPath != null ? Path.GetFileName(_currentVideoPath) : "video*.mp4";
                        Dispatcher.Invoke(() =>
                        {
                            _currentOperation = $"正在生成{videoFileName}文件";
                            UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                        });
                        
                        // 等待音频管道数据刷新（实时合成模式）或音频文件写入完成（文件合并模式）
                        System.Threading.Thread.Sleep(1000);
                        
                        // 检查是否是实时合成模式（_hasAudioInVideo = true 且没有找到音频设备）
                        // 如果是实时合成模式，不需要查找和合并音频文件
                        // 如果是文件合并模式，需要查找音频文件并合并
                        
                        // 注意：VideoEncoder.Finish() 会根据 _hasAudioInVideo 判断是否需要合并
                        // 如果是实时合成模式，_hasAudioInVideo = true，Finish() 会跳过合并
                        // 如果是文件合并模式，_hasAudioInVideo = false，Finish() 会查找 _tempAudioPath 并合并
                        
                        // 只有在文件合并模式下，才需要查找和设置音频文件路径
                        // 实时合成模式下，音频已经通过管道写入 FFmpeg，无需合并
                        
                        // 尝试查找临时音频文件（仅在文件合并模式下需要）
                        var tempAudioFiles = Directory.GetFiles(_workDir, "audio_*.wav");
                        if (tempAudioFiles.Length == 0)
                        {
                            tempAudioFiles = Directory.GetFiles(_workDir, "temp_audio_*.wav");
                        }
                        
                        if (tempAudioFiles.Length > 0)
                        {
                            var latestAudioFile = tempAudioFiles.OrderByDescending(f => File.GetCreationTime(f)).First();
                            var audioFileInfo = new FileInfo(latestAudioFile);
                            
                            // 设置音频文件路径（VideoEncoder.Finish() 会根据 _hasAudioInVideo 决定是否使用）
                            if (audioFileInfo.Length > 0)
                            {
                                _videoEncoder?.SetAudioFile(latestAudioFile);
                            }
                        }
                        
                        // 现在停止视频录制并完成编码
                        // 注意：如果是实时合成模式，Finish() 会跳过合并；如果是文件合并模式，Finish() 会合并音频
                        WriteLine($"准备停止视频录制（FFmpeg）并完成编码");
                        _videoEncoder?.Finish(); // 这会发送 'q' 给 FFmpeg，等待退出，然后根据模式决定是否合并音频
                        WriteLine($"视频编码完成");

                        // 释放资源
                        _videoEncoder?.Dispose();

                        // 完成PPT和PDF生成（在MP4生成完成后立即执行）
                        List<string> generatedFiles = new List<string>();
                        if (File.Exists(_currentVideoPath))
                        {
                            generatedFiles.Add(Path.GetFileName(_currentVideoPath));
                        }
                        
                        if (_config.GeneratePPT || _config.GeneratePDF)
                        {
                            if (_config.GeneratePPT && _pptFilePath != null)
                            {
                                string pptFileName = Path.GetFileName(_pptFilePath);
                                Dispatcher.Invoke(() =>
                                {
                                    _currentOperation = $"正在生成{pptFileName}文件";
                                    UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                                });
                            }
                            
                            if (_config.GeneratePDF && _pdfFilePath != null)
                            {
                                string pdfFileName = Path.GetFileName(_pdfFilePath);
                                Dispatcher.Invoke(() =>
                                {
                                    _currentOperation = $"正在生成{pdfFileName}文件";
                                    UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                                });
                            }
                        }
                        
                        WriteLine($"准备完成PPT和PDF生成");
                        FinalizePPTAndPDF();
                        WriteLine($"PPT和PDF生成完成");
                        
                        // 收集所有生成的文件名
                        if (_config.GeneratePPT && _pptFilePath != null && File.Exists(_pptFilePath))
                        {
                            generatedFiles.Add(Path.GetFileName(_pptFilePath));
                        }
                        if (_config.GeneratePDF && _pdfFilePath != null && File.Exists(_pdfFilePath))
                        {
                            generatedFiles.Add(Path.GetFileName(_pdfFilePath));
                        }

                        // 在 UI 线程更新界面
                        Dispatcher.Invoke(() =>
                        {
                            _videoEncoder = null;
                            _isVideoRecording = false;
                            
                            // 停止截图定时器
                            if (_screenshotTimer != null && _screenshotTimer.IsEnabled)
                            {
                                _screenshotTimer.Stop();
                                WriteLine("截图定时器已停止");
                            }
                            
                            // 更新按钮状态（考虑区域选择情况）
                            UpdateStartButtonState();
                            
                            // 清除当前操作，恢复正常状态显示
                            _isStoppingRecording = false;
                            _currentOperation = "";
                            
                            // 显示成功消息（只显示成功消息，不显示配置信息）
                            if (generatedFiles.Count > 0)
                            {
                                UpdateStatusDisplayOnly("恭喜，所有文件正确生成", new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 235))); // 天蓝色
                            }
                            else
                            {
                                UpdateStatusDisplay("视频录制已停止");
                            }
                            
                            // 清除当前视频路径
                            _currentVideoPath = null;
                        });
                    }
                    catch (Exception ex)
                    {
                        WriteError($"停止录制失败", ex);
                        Dispatcher.Invoke(() =>
                        {
                            // 停止状态更新定时器
                            _statusUpdateTimer?.Stop();
                            _statusUpdateTimer = null;
                            _currentOperation = "";
                            _isStoppingRecording = false;
                            
                            UpdateStatusDisplay($"停止录制失败：{ex.Message}");
                            UpdateStartButtonState();
                        });
                    }
                });
            }
            catch (Exception ex)
            {
                // 停止状态更新定时器
                _statusUpdateTimer?.Stop();
                _statusUpdateTimer = null;
                _currentOperation = "";
                _isStoppingRecording = false;
                
                UpdateStatusDisplay($"停止录制视频失败：{ex.Message}");
                UpdateStartButtonState();
            }
        }

        private void OnAudioSampleAvailable(byte[]? audioData, int bytesRecorded)
        {
            // 音频样本可用事件：将音频数据实时传递给 FFmpeg（边录边合成）
            if (audioData != null && bytesRecorded > 0 && _videoEncoder != null)
            {
                _videoEncoder.WriteAudioData(audioData, bytesRecorded);
            }
        }


        /// <summary>
        /// 动态计算并设置信息显示区域的宽度
        /// </summary>
        private void UpdateStatusBarInfoWidth()
        {
            try
            {
                if (StatusBarInfo == null) return;
                
                // 等待布局完成
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    try
                    {
                        // 获取窗口实际宽度
                        double windowWidth = this.ActualWidth;
                        
                        if (windowWidth <= 0) return;
                        
                        // 减去 Grid 的左右 Margin (8+8=16)
                        double availableWidth = windowWidth - 16;
                        
                        // 根据窗口宽度动态计算信息显示区域的宽度
                        // 使用窗口宽度的约 35-40% 作为信息显示区域
                        // 对于 1920px 屏幕的 80% (1536px)，信息区域约为 500-600px
                        // 对于较小屏幕，按比例调整，但最小不少于 200px
                        double statusBarWidth = Math.Max(200, availableWidth * 0.35);
                        
                        // 设置宽度
                        StatusBarInfo.Width = statusBarWidth;
                    }
                    catch (Exception ex)
                    {
                        WriteError($"延迟更新信息显示区域宽度失败", ex);
                    }
                }), System.Windows.Threading.DispatcherPriority.Loaded);
            }
            catch (Exception ex)
            {
                WriteError($"更新信息显示区域宽度失败", ex);
            }
        }

        private void UpdateConfigDisplay()
        {
            UpdateStatusDisplay(null);
        }

        /// <summary>
        /// 状态更新定时器事件
        /// </summary>
        private void StatusUpdateTimer_Tick(object? sender, EventArgs e)
        {
            if (_isVideoRecording && !_isStoppingRecording)
            {
                // 录制中：显示屏幕变化率、录制间隔、截图数量
                UpdateRecordingStatus();
            }
        }

        /// <summary>
        /// 录制时长检查定时器事件
        /// </summary>
        private void DurationCheckTimer_Tick(object? sender, EventArgs e)
        {
            try
            {
                if (!_isVideoRecording || _isStoppingRecording || _recordingDurationMinutes <= 0)
                {
                    return;
                }

                DateTime now = DateTime.Now;
                TimeSpan elapsed = now - _recordingStartTime;
                int elapsedSeconds = (int)elapsed.TotalSeconds;
                int durationSeconds = _recordingDurationMinutes * 60;

                // 检查是否到达录制时长
                if (elapsedSeconds >= durationSeconds)
                {
                    WriteLine($"录制时长已到达 {_recordingDurationMinutes} 分钟，自动停止录制");
                    
                    // 停止时长检查定时器
                    _durationCheckTimer?.Stop();
                    _durationCheckTimer = null;
                    
                    // 自动停止录制
                    Dispatcher.Invoke(() =>
                    {
                        if (_isVideoRecording && !_isStoppingRecording)
                        {
                            BtnStopVideo_Click(BtnStopVideo, new RoutedEventArgs());
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                WriteError($"录制时长检查失败", ex);
            }
        }

        /// <summary>
        /// 更新录制状态显示
        /// </summary>
        private void UpdateRecordingStatus()
        {
            try
            {
                if (_isStoppingRecording)
                {
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                    }
                    return;
                }

                // 计算录制已用时间和剩余时间
                DateTime now = DateTime.Now;
                TimeSpan recordingElapsed = now - _recordingStartTime;
                string timeInfo = "";
                if (_recordingDurationMinutes > 0)
                {
                    int remainingRecordingSeconds = _recordingDurationMinutes * 60 - (int)recordingElapsed.TotalSeconds;
                    if (remainingRecordingSeconds > 0)
                    {
                        int mins = remainingRecordingSeconds / 60;
                        int secs = remainingRecordingSeconds % 60;
                        timeInfo = $" | 剩余: {mins}分{secs}秒";
                    }
                    else
                    {
                        timeInfo = " | 剩余: 0秒";
                    }
                }
                else
                {
                    int elapsedMinutes = (int)recordingElapsed.TotalMinutes;
                    int elapsedSeconds = (int)recordingElapsed.TotalSeconds % 60;
                    timeInfo = $" | 已录制: {elapsedMinutes}分{elapsedSeconds}秒";
                }

                // 如果截图功能未启用，显示提示信息
                if (!_isScreenshotEnabled)
                {
                    string statusText = $"屏幕变化率: -- | " +
                                       $"截图数量: {_screenshotCount} (请启用截图功能){timeInfo}";
                    UpdateStatusDisplayWithScroll(statusText, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                    return;
                }
                
                // 计算距离下次检查的剩余时间
                TimeSpan elapsed = now - _lastScreenshotTime;
                int remainingCheckSeconds = Math.Max(0, _config.ScreenshotInterval - (int)elapsed.TotalSeconds);
                
                // 始终显示实时的屏幕变化率（比较当前画面和上一次检查时的画面）
                string mainStatusText = $"屏幕变化率: {_currentScreenChangeRate:F2}% | " +
                                       $"截图数量: {_screenshotCount}{timeInfo}";
                
                // 使用Inlines来设置不同颜色的文本
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    // 使用天蓝色和粉红色交替显示信息
                    var parts = mainStatusText.Split('|');
                    for (int i = 0; i < parts.Length; i++)
                    {
                        string part = parts[i].Trim();
                        if (string.IsNullOrEmpty(part)) continue;
                        
                        // 交替使用天蓝色和粉红色
                        var color = (i % 2 == 0) 
                            ? new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 250)) // 天蓝色
                            : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)); // 粉红色
                        StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(part) 
                        { 
                            Foreground = color 
                        });
                        
                        // 添加分隔符（除了最后一个）
                        if (i < parts.Length - 1)
                        {
                            StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(" | ") 
                            { 
                                Foreground = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(135, 206, 250)) // 天蓝色
                            });
                        }
                    }
                    
                    if (remainingCheckSeconds > 0 && _lastScreenshot != null)
                    {
                        // 如果间隔时间未到达，在变化率后面显示剩余时间（使用粉红色）
                        StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run($" (下次检查: {remainingCheckSeconds}秒后)") 
                        { 
                            Foreground = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)) // 粉红色
                        });
                    }
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新录制状态失败", ex);
            }
        }

        /// <summary>
        /// 更新状态栏显示（合并配置信息和状态信息为一行，用不同颜色显示）
        /// </summary>
        /// <param name="statusText">状态文本，如果为null则使用当前状态</param>
        private void UpdateStatusDisplay(string? statusText = null, System.Windows.Media.Brush? statusColor = null)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    if (_isStoppingRecording && !string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                        return;
                    }

                    // 如果正在录制，显示录制状态
                    if (_isVideoRecording && statusText == null)
                    {
                        UpdateRecordingStatus();
                        return;
                    }

                    // 如果正在停止录制，显示当前操作
                    if (!string.IsNullOrEmpty(_currentOperation))
                    {
                        UpdateStatusDisplayWithScroll(_currentOperation, new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203))); // 粉红色
                        return;
                    }

                    // 状态信息（绿色表示正常，橙色表示警告，红色表示错误）
                    string status = statusText ?? "就绪";
                    System.Windows.Media.Brush finalStatusColor = statusColor ?? System.Windows.Media.Brushes.Green;
                    
                    // 如果没有指定颜色，根据状态文本判断颜色
                    if (statusColor == null)
                    {
                        if (status.Contains("失败") || status.Contains("错误"))
                        {
                            finalStatusColor = System.Windows.Media.Brushes.Red;
                        }
                        else if (status.Contains("警告") || status.Contains("正在"))
                        {
                            finalStatusColor = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 192, 203)); // 粉红色
                        }
                    }

                    // 只显示状态信息
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(status) 
                    { 
                        Foreground = finalStatusColor
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }

        /// <summary>
        /// 更新状态显示（只显示状态文本，不显示配置信息）
        /// </summary>
        private void UpdateStatusDisplayOnly(string statusText, System.Windows.Media.Brush color)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(statusText) 
                    { 
                        Foreground = color
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }

        /// <summary>
        /// 更新状态显示（带滚动支持）
        /// </summary>
        private void UpdateStatusDisplayWithScroll(string statusText, System.Windows.Media.Brush color)
        {
            try
            {
                if (StatusBarInfo != null)
                {
                    StatusBarInfo.Inlines.Clear();
                    StatusBarInfo.Inlines.Add(new System.Windows.Documents.Run(statusText) 
                    { 
                        Foreground = color 
                    });
                    
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新状态显示失败", ex);
            }
        }


        private bool HasValidCustomRegion()
        {
            return _config.UseCustomRegion &&
                   _config.RegionWidth > 0 &&
                   _config.RegionHeight > 0;
        }

        /// <summary>
        /// 初始化按钮状态：只有选择按钮可用，开始和停止按钮禁用
        /// </summary>
        private void InitializeButtonStates()
        {
            try
            {
                if (BtnStartVideo != null)
                {
                    BtnStartVideo.IsEnabled = false;
                }
                if (BtnStopVideo != null)
                {
                    BtnStopVideo.IsEnabled = false;
                }
                if (BtnSelectRegion != null)
                {
                    BtnSelectRegion.IsEnabled = true;
                }
            }
            catch (Exception ex)
            {
                WriteError($"初始化按钮状态失败", ex);
            }
        }

        /// <summary>
        /// 更新开始按钮的启用状态
        /// 如果没有有效区域，则禁用开始按钮
        /// </summary>
        private void UpdateStartButtonState()
        {
            try
            {
                if (BtnStartVideo != null)
                {
                    // 如果没有有效区域，则禁用开始按钮
                    if (!HasValidCustomRegion())
                    {
                        BtnStartVideo.IsEnabled = false;
                    }
                    else
                    {
                        // 否则启用开始按钮（除非正在录制）
                        BtnStartVideo.IsEnabled = !_isVideoRecording;
                    }
                }
                // 停止按钮始终跟随录制状态
                if (BtnStopVideo != null)
                {
                    BtnStopVideo.IsEnabled = _isVideoRecording;
                }
                // 选择按钮：录制时禁用，否则启用
                if (BtnSelectRegion != null)
                {
                    BtnSelectRegion.IsEnabled = !_isVideoRecording;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新开始按钮状态失败", ex);
            }
        }

        private void UpdateRegionOverlay()
        {
            try
            {
                // 如果没有有效的自定义区域，则隐藏
                if (!HasValidCustomRegion())
                {
                    _regionHighlightWindow?.HideRegion();
                    return;
                }

                // 有有效区域，显示红色矩形框
                if (_regionHighlightWindow == null)
                {
                    _regionHighlightWindow = new RegionHighlightWindow();
                    // 只在主窗口已显示时设置 Owner
                    if (IsLoaded && IsVisible)
                    {
                        _regionHighlightWindow.Owner = this;
                    }
                }
                else if (IsLoaded && IsVisible && _regionHighlightWindow.Owner == null)
                {
                    // 如果之前没有设置 Owner，现在设置
                    _regionHighlightWindow.Owner = this;
                }

                var rect = new Int32Rect(
                    _config.RegionLeft,
                    _config.RegionTop,
                    _config.RegionWidth,
                    _config.RegionHeight);

                _regionHighlightWindow.ShowRegion(rect);
            }
            catch (Exception ex)
            {
                WriteError($"更新区域高亮失败", ex);
            }
        }

        private void BtnSelectRegion_Click(object sender, RoutedEventArgs e)
        {
            RegionSelectionWindow? selector = null;
            try
            {
                if (_isVideoRecording)
                {
                    UpdateStatusDisplay("请先停止录制，再调整录制区域");
                    return;
                }

                selector = new RegionSelectionWindow
                {
                    Owner = this
                };

                bool? dialogResult = selector.ShowDialog();
                if (dialogResult == true)
                {
                    var rect = selector.SelectedRect;
                    if (rect.Width > 0 && rect.Height > 0)
                    {
                        // 验证区域是否在主屏幕范围内
                        var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                        int regionRight = rect.X + rect.Width;
                        int regionBottom = rect.Y + rect.Height;
                        
                        if (rect.X < 0 || rect.Y < 0 || regionRight > screenWidth || regionBottom > screenHeight)
                        {
                            string warningMsg = $"选择的区域部分超出主屏幕范围！\n" +
                                               $"区域: ({rect.X}, {rect.Y}) 到 ({regionRight}, {regionBottom})\n" +
                                               $"主屏幕: (0, 0) 到 ({screenWidth}, {screenHeight})\n" +
                                               $"录制时只会录制主屏幕范围内的部分。\n\n" +
                                               $"是否继续使用此区域？";
                            
                            WriteWarning(warningMsg);
                            
                            var result = MessageBox.Show(warningMsg, "区域超出范围", 
                                MessageBoxButton.YesNo, MessageBoxImage.Warning);
                            
                            if (result == MessageBoxResult.No)
                            {
                                UpdateStatusDisplay("已取消选择区域");
                                return;
                            }
                        }
                        
                        _config.UseCustomRegion = true;
                        _config.RegionLeft = rect.X;
                        _config.RegionTop = rect.Y;
                        _config.RegionWidth = rect.Width;
                        _config.RegionHeight = rect.Height;
                        _config.Save(_configPath);

                        // 用户选择新区域后，总是显示红色矩形框（不受配置影响）
                        UpdateRegionOverlay();
                        UpdateConfigDisplay();
                        
                        // 选择区域后，更新开始按钮状态
                        UpdateStartButtonState();

                        WriteLine($"选择录制区域: 左上=({rect.X},{rect.Y}), 大小={rect.Width}x{rect.Height}");
                        UpdateStatusDisplay($"已选择区域：{rect.Width}x{rect.Height} @ ({rect.X},{rect.Y})");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"选择录制区域失败", ex);
                UpdateStatusDisplay($"选择录制区域失败：{ex.Message}");
            }
            finally
            {
                // 确保窗口正确关闭和清理
                try
                {
                    if (selector != null && selector.IsVisible)
                    {
                        selector.Close();
                    }
                }
                catch
                {
                    // 忽略关闭错误
                }
            }
        }

        /// <summary>
        /// 恢复最近一次框选的区域
        /// </summary>
        private void BtnRestoreRegion_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_isVideoRecording)
                {
                    UpdateStatusDisplay("请先停止录制，再恢复录制区域");
                    return;
                }

                // 检查配置中是否有有效的区域
                if (!HasValidCustomRegion())
                {
                    UpdateStatusDisplay("没有可恢复的区域，请先选择区域");
                    WriteLine("恢复区域失败：配置中没有有效的区域信息");
                    return;
                }

                // 验证区域是否在主屏幕范围内
                var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                int regionRight = _config.RegionLeft + _config.RegionWidth;
                int regionBottom = _config.RegionTop + _config.RegionHeight;

                if (_config.RegionLeft < 0 || _config.RegionTop < 0 ||
                    regionRight > screenWidth || regionBottom > screenHeight)
                {
                    string warningMsg = $"保存的区域部分超出主屏幕范围！\n" +
                                       $"区域: ({_config.RegionLeft}, {_config.RegionTop}) 到 ({regionRight}, {regionBottom})\n" +
                                       $"主屏幕: (0, 0) 到 ({screenWidth}, {screenHeight})\n" +
                                       $"是否继续使用此区域？";

                    WriteWarning(warningMsg);

                    var result = MessageBox.Show(warningMsg, "区域超出范围",
                        MessageBoxButton.YesNo, MessageBoxImage.Warning);

                    if (result == MessageBoxResult.No)
                    {
                        UpdateStatusDisplay("已取消恢复区域");
                        return;
                    }
                }

                // 恢复区域：确保 UseCustomRegion 为 true
                _config.UseCustomRegion = true;
                _config.Save(_configPath);

                // 更新界面显示
                UpdateRegionOverlay();
                UpdateConfigDisplay();
                UpdateStartButtonState();

                WriteLine($"恢复录制区域: 左上=({_config.RegionLeft},{_config.RegionTop}), 大小={_config.RegionWidth}x{_config.RegionHeight}");
                UpdateStatusDisplay($"已恢复区域：{_config.RegionWidth}x{_config.RegionHeight} @ ({_config.RegionLeft},{_config.RegionTop})");
            }
            catch (Exception ex)
            {
                WriteError($"恢复录制区域失败", ex);
                UpdateStatusDisplay($"恢复录制区域失败：{ex.Message}");
            }
        }

        private (int width, int height) GetPrimaryScreenPixelSize()
        {
            int width = GetSystemMetrics(SM_CXSCREEN);
            int height = GetSystemMetrics(SM_CYSCREEN);

            if (width <= 0 || height <= 0)
            {
                // 回退到 WPF 的 SystemParameters（单位为 DIP，需要乘 DPI 比例，但通常足够）
                width = (int)SystemParameters.PrimaryScreenWidth;
                height = (int)SystemParameters.PrimaryScreenHeight;
            }

            return (width, height);
        }

        private const int SM_CXSCREEN = 0;
        private const int SM_CYSCREEN = 1;

        [DllImport("user32.dll")]
        private static extern int GetSystemMetrics(int nIndex);

        /// <summary>
        /// 初始化界面上的设置输入框
        /// </summary>
        private void InitializeSettingsControls()
        {
            try
            {
                if (TxtScreenChangeRate != null)
                {
                    TxtScreenChangeRate.Text = _config.ScreenChangeRate.ToString("F2");
                }
                if (TxtScreenshotInterval != null)
                {
                    TxtScreenshotInterval.Text = _config.ScreenshotInterval.ToString();
                }
                if (TxtRecordingDuration != null)
                {
                    TxtRecordingDuration.Text = _recordingDurationMinutes.ToString();
                }
            }
            catch (Exception ex)
            {
                WriteError($"初始化设置控件失败", ex);
            }
        }

        /// <summary>
        /// 屏幕变化率输入框文本更改事件
        /// </summary>
        private void TxtScreenChangeRate_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtScreenChangeRate != null && double.TryParse(TxtScreenChangeRate.Text, out double value))
                {
                    // 验证范围：1-1000
                    if (value < 1)
                    {
                        value = 1;
                        TxtScreenChangeRate.Text = "1";
                    }
                    else if (value > 1000)
                    {
                        value = 1000;
                        TxtScreenChangeRate.Text = "1000";
                    }
                    
                    // 更新配置并保存
                    if (Math.Abs(_config.ScreenChangeRate - value) > 0.01) // 避免频繁保存（浮点数比较）
                    {
                        _config.ScreenChangeRate = value;
                        _config.Save(_configPath);
                        WriteLine($"屏幕变化率已更新: {value:F2}%");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新屏幕变化率失败", ex);
            }
        }

        /// <summary>
        /// 截图间隔输入框文本更改事件
        /// </summary>
        private void TxtScreenshotInterval_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtScreenshotInterval != null && int.TryParse(TxtScreenshotInterval.Text, out int value))
                {
                    // 验证范围：1-65535
                    if (value < 1)
                    {
                        value = 1;
                        TxtScreenshotInterval.Text = "1";
                    }
                    else if (value > 65535)
                    {
                        value = 65535;
                        TxtScreenshotInterval.Text = "65535";
                    }
                    
                    // 更新配置并保存
                    if (_config.ScreenshotInterval != value)
                    {
                        _config.ScreenshotInterval = value;
                        _config.Save(_configPath);
                        WriteLine($"截图间隔已更新: {value}秒");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新截图间隔失败", ex);
            }
        }

        /// <summary>
        /// 录制时长输入框文本更改事件
        /// </summary>
        private void TxtRecordingDuration_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            try
            {
                if (TxtRecordingDuration != null && int.TryParse(TxtRecordingDuration.Text, out int value))
                {
                    // 验证范围：0-9999（0表示无限制）
                    if (value < 0)
                    {
                        value = 0;
                        TxtRecordingDuration.Text = "0";
                    }
                    else if (value > 9999)
                    {
                        value = 9999;
                        TxtRecordingDuration.Text = "9999";
                    }
                    
                    // 更新录制时长
                    if (_recordingDurationMinutes != value)
                    {
                        _recordingDurationMinutes = value;
                        WriteLine($"录制时长已更新: {(_recordingDurationMinutes == 0 ? "无限制" : $"{_recordingDurationMinutes}分钟")}");
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"录制时长输入框文本更改失败", ex);
            }
        }

        /// <summary>
        /// 更新日志菜单项状态
        /// </summary>
        private void UpdateLogMenuItems()
        {
            try
            {
                // 更新日志开关状态
                if (MenuLogEnabled != null)
                {
                    MenuLogEnabled.IsChecked = _config.LogEnabled == 1;
                }
                if (MenuLogDisabled != null)
                {
                    MenuLogDisabled.IsChecked = _config.LogEnabled == 0;
                }

                // 更新日志文件模式状态
                if (MenuLogFileOverwrite != null)
                {
                    MenuLogFileOverwrite.IsChecked = _config.LogFileMode == 0;
                }
                if (MenuLogFileAppend != null)
                {
                    MenuLogFileAppend.IsChecked = _config.LogFileMode == 1;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新日志菜单项状态失败", ex);
            }
        }

        /// <summary>
        /// 更新PPT和PDF菜单项状态
        /// </summary>
        private void UpdatePPTAndPDFMenuItems()
        {
            try
            {
                // 如果截图功能未开启，禁用PPT和PDF菜单项
                bool isEnabled = _isScreenshotEnabled;
                
                if (MenuGeneratePPT != null)
                {
                    MenuGeneratePPT.IsChecked = _config.GeneratePPT;
                    MenuGeneratePPT.IsEnabled = isEnabled;
                }
                if (MenuGeneratePDF != null)
                {
                    MenuGeneratePDF.IsChecked = _config.GeneratePDF;
                    MenuGeneratePDF.IsEnabled = isEnabled;
                }
            }
            catch (Exception ex)
            {
                WriteError($"更新PPT和PDF菜单项状态失败", ex);
            }
        }

        /// <summary>
        /// 保存日志配置
        /// </summary>
        private void SaveLogConfig()
        {
            try
            {
                _config.Save(_configPath);
                Logger.SetLogFileMode(_config.LogFileMode);
                // 如果切换到覆盖模式，需要重新设置日志目录以清空文件
                if (_config.LogFileMode == 0)
                {
                    Logger.SetLogDirectory(_workDir, applyMode: true);
                }
                // 只有在日志启用时才写入日志（避免在禁用时写入）
                if (_config.LogEnabled == 1)
                {
                    Logger.WriteLine($"日志配置已更新: 状态={(_config.LogEnabled == 1 ? "启用" : "禁用")}, 模式={(_config.LogFileMode == 0 ? "覆盖" : "叠加")}");
                }
            }
            catch (Exception ex)
            {
                WriteError($"保存日志配置失败", ex);
            }
        }

        private void MenuLogEnabled_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogEnabled = 1;
                Logger.Enabled = true;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志已启用");
            }
            catch (Exception ex)
            {
                WriteError($"启用日志失败", ex);
            }
        }

        private void MenuLogDisabled_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogEnabled = 0;
                Logger.Enabled = false;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志已禁用");
            }
            catch (Exception ex)
            {
                WriteError($"禁用日志失败", ex);
            }
        }

        private void MenuLogFileOverwrite_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogFileMode = 0;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志文件模式：覆盖");
            }
            catch (Exception ex)
            {
                WriteError($"设置日志文件覆盖模式失败", ex);
            }
        }

        private void MenuLogFileAppend_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.LogFileMode = 1;
                UpdateLogMenuItems();
                SaveLogConfig();
                UpdateStatusDisplay("日志文件模式：叠加");
            }
            catch (Exception ex)
            {
                WriteError($"设置日志文件叠加模式失败", ex);
            }
        }

        private void MenuScreenshot_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _isScreenshotEnabled = MenuScreenshot.IsChecked;
                
                if (_isScreenshotEnabled)
                {
                    // 启动截图定时器
                    if (_screenshotTimer != null)
                    {
                        // 设置定时器间隔为1秒，但实际检查逻辑会按照配置的间隔执行
                        _screenshotTimer.Interval = TimeSpan.FromSeconds(1);
                        _screenshotTimer.Start();
                        _lastScreenshotTime = DateTime.Now;
                        // 立即初始化 _lastScreenshot，作为第一次检查的基准画面
                        UpdateLastScreenshot();
                        
                        // 重置PPT/PDF初始化状态，准备创建新的PPT/PDF文件
                        _pptPdfInitialized = false;
                        _pptGenerator?.Dispose();
                        _pdfGenerator?.Dispose();
                        _pptGenerator = null;
                        _pdfGenerator = null;
                        
                        WriteLine("截图功能已启用");
                        UpdateStatusDisplay("截图功能已启用");
                    }
                }
                else
                {
                    // 停止截图定时器
                    if (_screenshotTimer != null)
                    {
                        _screenshotTimer.Stop();
                    }
                    _lastScreenshot?.Dispose();
                    _lastScreenshot = null;
                    
                    // 完成并释放PPT/PDF生成器
                    FinalizePPTAndPDF();
                    
                    WriteLine("截图功能已禁用");
                    UpdateStatusDisplay("截图功能已禁用");
                }
                
                // 更新PPT和PDF菜单项的启用状态
                UpdatePPTAndPDFMenuItems();
            }
            catch (Exception ex)
            {
                WriteError($"切换截图功能失败", ex);
                UpdateStatusDisplay($"切换截图功能失败：{ex.Message}");
            }
        }

        private void MenuGeneratePPT_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.GeneratePPT = MenuGeneratePPT.IsChecked;
                _config.Save(_configPath);
                WriteLine($"生成PPT: {(_config.GeneratePPT ? "启用" : "禁用")}");
                UpdateStatusDisplay($"生成PPT: {(_config.GeneratePPT ? "已启用" : "已禁用")}");
            }
            catch (Exception ex)
            {
                WriteError($"切换生成PPT功能失败", ex);
                UpdateStatusDisplay($"切换生成PPT功能失败：{ex.Message}");
            }
        }

        private void MenuGeneratePDF_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _config.GeneratePDF = MenuGeneratePDF.IsChecked;
                _config.Save(_configPath);
                WriteLine($"生成PDF: {(_config.GeneratePDF ? "启用" : "禁用")}");
                UpdateStatusDisplay($"生成PDF: {(_config.GeneratePDF ? "已启用" : "已禁用")}");
            }
            catch (Exception ex)
            {
                WriteError($"切换生成PDF功能失败", ex);
                UpdateStatusDisplay($"切换生成PDF功能失败：{ex.Message}");
            }
        }


        private void ScreenshotTimer_Tick(object? sender, EventArgs e)
        {
            try
            {
                // 只有在截图功能启用且正在录制时才处理
                if (!_isScreenshotEnabled || !_isVideoRecording) return;

                DateTime now = DateTime.Now;
                TimeSpan elapsed = now - _lastScreenshotTime;
                
                // 持续计算屏幕变化率（用于实时显示）
                // 这比较的是"上一次检查时的画面"（间隔时间前的画面）和"当前画面"的变化率
                // 注意：这里不更新 _lastScreenshot，只计算变化率用于显示
                double changeRate = CalculateScreenChangeRateForDisplay();
                _currentScreenChangeRate = changeRate;
                
                // 检查是否到了截图间隔时间
                if (elapsed.TotalSeconds >= _config.ScreenshotInterval)
                {
                    // 间隔时间到达，检查是否需要截图
                    if (changeRate >= _config.ScreenChangeRate || _lastScreenshot == null)
                    {
                        // 屏幕变化率超过阈值，执行截图
                        CaptureScreenshot();
                    }
                    
                    // 间隔时间到达，更新 _lastScreenshot 为当前画面（保存为"上一次检查时的画面"）
                    UpdateLastScreenshot();
                    _lastScreenshotTime = now;
                }
            }
            catch (Exception ex)
            {
                WriteError($"截图定时器处理失败", ex);
            }
        }

        /// <summary>
        /// 计算屏幕变化率（仅用于显示，不更新 _lastScreenshot）
        /// 比较"上一次检查时的画面"（间隔时间前的画面）和"当前画面"的变化率
        /// </summary>
        private double CalculateScreenChangeRateForDisplay()
        {
            Bitmap? currentScreenshot = null;
            try
            {
                // 获取当前屏幕截图
                currentScreenshot = CaptureScreenBitmap();
                
                if (_lastScreenshot == null)
                {
                    // 第一次，还没有基准画面，返回最大值
                    currentScreenshot?.Dispose();
                    return 1000;
                }

                // 检查两张图片的尺寸是否匹配
                if (currentScreenshot.Width != _lastScreenshot.Width || 
                    currentScreenshot.Height != _lastScreenshot.Height)
                {
                    // 尺寸不匹配（可能是区域选择改变了），返回最大值表示需要更新
                    currentScreenshot?.Dispose();
                    return 1000;
                }

                // 比较两张图片的差异（参考Python代码的pixel_diff函数）
                // Python逻辑：np.any(diff > 20, axis=2) - 如果任何一个颜色通道的差值超过20，认为像素变化
                int changedPixels = 0;

                // 为了提高性能，使用采样方式（每5个像素采样一次）
                // 但计算方式与Python保持一致：检查任何一个通道是否超过20
                int sampleRate = 5;
                int sampledPixels = 0;
                
                // 使用较小的尺寸确保不越界
                int width = Math.Min(currentScreenshot.Width, _lastScreenshot.Width);
                int height = Math.Min(currentScreenshot.Height, _lastScreenshot.Height);
                
                for (int y = 0; y < height; y += sampleRate)
                {
                    for (int x = 0; x < width; x += sampleRate)
                    {
                        // 确保坐标在有效范围内
                        if (x >= currentScreenshot.Width || y >= currentScreenshot.Height ||
                            x >= _lastScreenshot.Width || y >= _lastScreenshot.Height)
                        {
                            continue;
                        }
                        
                        Color currentColor = currentScreenshot.GetPixel(x, y);
                        Color lastColor = _lastScreenshot.GetPixel(x, y);
                        
                        // 计算每个颜色通道的差值（参考Python: np.abs(arr1 - arr2)）
                        int diffR = Math.Abs(currentColor.R - lastColor.R);
                        int diffG = Math.Abs(currentColor.G - lastColor.G);
                        int diffB = Math.Abs(currentColor.B - lastColor.B);
                        
                        // Python逻辑：np.any(diff > 20, axis=2) - 如果任何一个通道差值超过20，认为像素变化
                        if (diffR > 20 || diffG > 20 || diffB > 20)
                        {
                            changedPixels++;
                        }
                        sampledPixels++;
                    }
                }

                // 计算变化率（百分比）：基于采样像素的变化率
                // Python逻辑：rate = (changed_count / total) * 100
                double sampledChangeRate = (changedPixels / (double)sampledPixels) * 100.0;
                
                // 释放当前截图（不更新 _lastScreenshot）
                currentScreenshot?.Dispose();
                
                return sampledChangeRate;
            }
            catch (Exception ex)
            {
                WriteError($"计算屏幕变化率失败", ex);
                currentScreenshot?.Dispose(); // 确保在异常时释放资源
                return 0;
            }
        }

        /// <summary>
        /// 更新 _lastScreenshot 为当前画面（仅在间隔时间到达时调用）
        /// </summary>
        private void UpdateLastScreenshot()
        {
            try
            {
                Bitmap? currentScreenshot = CaptureScreenBitmap();
                _lastScreenshot?.Dispose();
                _lastScreenshot = currentScreenshot;
            }
            catch (Exception ex)
            {
                WriteError($"更新上次截图失败", ex);
            }
        }

        private Bitmap CaptureScreenBitmap()
        {
            try
            {
                // 如果设置了框选区域，只捕获框选区域；否则捕获整个屏幕
                if (HasValidCustomRegion())
                {
                    // 向内收缩几个像素，避开红色框的边框（红色框边框宽度为2像素，收缩3像素更安全）
                    const int borderOffset = 3;
                    int offsetX = _config.RegionLeft + borderOffset;
                    int offsetY = _config.RegionTop + borderOffset;
                    int width = _config.RegionWidth - borderOffset * 2;  // 左右各收缩
                    int height = _config.RegionHeight - borderOffset * 2; // 上下各收缩
                    
                    // 确保宽度和高度为正数
                    if (width <= 0) width = 1;
                    if (height <= 0) height = 1;
                    
                    Bitmap bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(
                            offsetX, 
                            offsetY, 
                            0, 
                            0, 
                            new System.Drawing.Size(width, height)
                        );
                    }
                    return bitmap;
                }
                else
                {
                    // 没有框选区域，捕获整个屏幕
                    var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                    Bitmap bitmap = new Bitmap(screenWidth, screenHeight);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(0, 0, 0, 0, new System.Drawing.Size(screenWidth, screenHeight));
                    }
                    return bitmap;
                }
            }
            catch (Exception ex)
            {
                WriteError($"捕获屏幕位图失败", ex);
                throw;
            }
        }

        private void CaptureScreenshot()
        {
            try
            {
                // 只有在正在录制时才截图，避免停止录制后继续生成PPT/PDF
                if (!_isVideoRecording)
                {
                    WriteLine("[截图] 跳过截图：录制已停止");
                    return;
                }

                int width, height;
                Bitmap bitmap;
                
                // 如果设置了框选区域，只捕获框选区域；否则捕获整个屏幕
                if (HasValidCustomRegion())
                {
                    // 向内收缩几个像素，避开红色框的边框（红色框边框宽度为2像素，收缩3像素更安全）
                    const int borderOffset = 3;
                    int offsetX = _config.RegionLeft + borderOffset;
                    int offsetY = _config.RegionTop + borderOffset;
                    width = _config.RegionWidth - borderOffset * 2;  // 左右各收缩
                    height = _config.RegionHeight - borderOffset * 2; // 上下各收缩
                    
                    // 确保宽度和高度为正数
                    if (width <= 0) width = 1;
                    if (height <= 0) height = 1;
                    
                    bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(
                            offsetX, 
                            offsetY, 
                            0, 
                            0, 
                            new System.Drawing.Size(width, height)
                        );
                    }
                }
                else
                {
                    var (screenWidth, screenHeight) = GetPrimaryScreenPixelSize();
                    width = screenWidth;
                    height = screenHeight;
                    bitmap = new Bitmap(width, height);
                    using (Graphics graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.CopyFromScreen(0, 0, 0, 0, new System.Drawing.Size(width, height));
                    }
                }
                
                using (bitmap)
                {
                    // 生成文件名：Picyymmddhhmmss.jpg
                    string fileName = $"Pic{DateTime.Now:yyMMddHHmmss}.jpg";
                    string filePath = Path.Combine(_screenshotDir, fileName);
                    
                    // 保存为JPG格式
                    ImageCodecInfo? jpegCodec = ImageCodecInfo.GetImageEncoders()
                        .FirstOrDefault(codec => codec.FormatID == ImageFormat.Jpeg.Guid);
                    
                    if (jpegCodec != null)
                    {
                        EncoderParameters encoderParams = new EncoderParameters(1);
                        encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, 90L); // 90%质量
                        bitmap.Save(filePath, jpegCodec, encoderParams);
                        encoderParams.Dispose();
                    }
                    else
                    {
                        // 如果没有找到JPEG编码器，使用默认方式保存
                        bitmap.Save(filePath, ImageFormat.Jpeg);
                    }
                    
                    WriteLine($"截图已保存: {filePath}");
                    
                    // 增加截图计数
                    _screenshotCount++;
                    
                    // 如果启用了PPT或PDF生成，立即添加到PPT/PDF
                    bool addedToPPT = false;
                    bool addedToPDF = false;
                    
                    if (_config.GeneratePPT || _config.GeneratePDF)
                    {
                        InitializePPTAndPDF(width, height);
                        
                        if (_config.GeneratePPT && _pptGenerator != null)
                        {
                            try
                            {
                                _pptGenerator.AddImage(filePath);
                                addedToPPT = true;
                            }
                            catch (Exception ex)
                            {
                                WriteError($"添加图片到PPT失败", ex);
                            }
                        }
                        
                        if (_config.GeneratePDF && _pdfGenerator != null)
                        {
                            try
                            {
                                _pdfGenerator.AddImage(filePath);
                                addedToPDF = true;
                            }
                            catch (Exception ex)
                            {
                                WriteError($"添加图片到PDF失败", ex);
                            }
                        }
                    }
                    
                    // 如果图片已成功添加到PPT或PDF，删除JPG文件（因为已包含在PPT/PDF中）
                    if ((_config.GeneratePPT && addedToPPT) || (_config.GeneratePDF && addedToPDF))
                    {
                        try
                        {
                            if (File.Exists(filePath))
                            {
                                File.Delete(filePath);
                                WriteLine($"已删除JPG文件（已添加到PPT/PDF）: {filePath}");
                            }
                        }
                        catch (Exception ex)
                        {
                            WriteError($"删除JPG文件失败: {filePath}", ex);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                WriteError($"截图保存失败", ex);
            }
        }

        private void InitializePPTAndPDF(int width, int height)
        {
            if (_pptPdfInitialized) return;
            
            try
            {
                if (_config.GeneratePPT)
                {
                    string timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                    _pptFilePath = Path.Combine(_screenshotDir, $"PPT{timestamp}.pptx");
                    _pptGenerator = new PPTGenerator(_pptFilePath, width, height);
                    _pptGenerator.Initialize();
                    WriteLine($"PPT生成器已初始化: {_pptFilePath}");
                }
                
                if (_config.GeneratePDF)
                {
                    string timestamp = DateTime.Now.ToString("yyMMddHHmmss");
                    _pdfFilePath = Path.Combine(_screenshotDir, $"PDF{timestamp}.pdf");
                    _pdfGenerator = new PDFGenerator(_pdfFilePath, width, height);
                    _pdfGenerator.Initialize();
                    WriteLine($"PDF生成器已初始化: {_pdfFilePath}");
                }
                
                _pptPdfInitialized = true;
            }
            catch (Exception ex)
            {
                WriteError($"初始化PPT/PDF生成器失败", ex);
            }
        }

        private void FinalizePPTAndPDF()
        {
            try
            {
                if (_config.GeneratePPT && _pptGenerator != null)
                {
                    _pptGenerator.Finish();
                    WriteLine($"PPT文件已生成: {_pptFilePath}");
                }
                
                if (_config.GeneratePDF && _pdfGenerator != null)
                {
                    _pdfGenerator.Finish();
                    WriteLine($"PDF文件已生成: {_pdfFilePath}");
                }
            }
            catch (Exception ex)
            {
                WriteError($"完成PPT/PDF生成失败", ex);
            }
            finally
            {
                _pptGenerator?.Dispose();
                _pdfGenerator?.Dispose();
                _pptGenerator = null;
                _pdfGenerator = null;
                _pptPdfInitialized = false;
            }
        }
    }
}
